/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entTemp = require("../../lib/entityTemplate").entityTemplate;
var async = require("async");
var util = require("util");
var self = {};

var wgLegend = function(schema)
{
  wgLegend.super_.call(this);

  this.moduleName = "Entity wgLegend";
  this.entityName = "wgLegend";
  this.schemaName = schema;
  this.tableName = "wg_legend";

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;

  this.retFieldObj = [{name:"id"},{name:"label"}];
}

/*
 * Inheritance.
 */
util.inherits(wgLegend,entTemp);

wgLegend.prototype.init = function(opt)
{
  self = this;
  wgLegend.super_.prototype.init.call(self,opt);
}

wgLegend.prototype.insert = function(opt,callback)
{
  var bDoTrans = false;
  var transName = opt.transName;

  // Look for transaction
  if (!transName)
  {
    bDoTrans = true;
    transName = "InsertLegend_" + new Date().getTime();
    opt.transName = transName;
  }

  // Look for classes array
  var aCls = opt.object.classesToIns ? opt.object.classesToIns : [];
  var aInsCls = [];

  for (var i = 0;i < aCls.length;i++)
  {
    aInsCls.push({
      sysuser_id: opt.sysuser_id,
      transName: transName,
      method: "insert",
      object: aCls[i]
    });
  }

  delete opt.object.classesToIns;

  // Look for i18n object
  var i18nOpt = {
    sysuser_id: opt.sysuser_id,
    transName: transName,
    object: opt.object.i18n
  };

  delete opt.object.i18n;

  /* Function to execute */
  var aFunc = {
    insert: function(cb) {wgLegend.super_.prototype.insert.call(self,opt,cb);},
    insCls: function(cb) {async.each(aInsCls,manageClass,cb);},
    insI18N: function(cb) {manageI18N(i18nOpt,"insert",cb);}
  };

  /* Execute */
  if (bDoTrans)
  {
    // Begin transaction
    self.crud.beginTransaction(transName,function(btErr)
    {
      if (btErr)
      {
        callback(btErr,null);
        return;
      }

      // Exec function
      async.parallelLimit(aFunc,1,function(err,res)
      {
        if (err)
        {
          self.crud.rollbackTransaction(transName,function(rtErr){});
          callback(err,null);
          return;
        }

        // Commit transaction
        self.crud.commitTransaction(transName,function(ctErr)
        {
          callback(ctErr,ctErr ? null : res.insert);
        });
      });
    });
  }
  else
  {
    async.parallelLimit(aFunc,1,function(err,res)
    {
      callback(err,err ? null : res.insert);
    });
  }
}

wgLegend.prototype.update = function(opt,callback)
{
  var bDoTrans = false;
  var transName = opt.transName;

  // Look for transaction
  if (!transName)
  {
    bDoTrans = true;
    transName = "UpdateLegend_" + new Date().getTime();
    opt.transName = transName;
  }

  // Look for classes array
  var aClsToIns = opt.object.classesToIns ? opt.object.classesToIns : [];
  var aClsToUpd = opt.object.classesToUpd ? opt.object.classesToUpd : [];
  var aInsCls = [];
  var aUpdCls = [];

  for (var i = 0;i < aClsToIns.length;i++)
  {
    aInsCls.push({
      sysuser_id: opt.sysuser_id,
      transName: transName,
      method: "insert",
      object: aClsToIns[i]
    });
  }
  for (var i = 0;i < aClsToUpd.length;i++)
  {
    aUpdCls.push({
      sysuser_id: opt.sysuser_id,
      transName: transName,
      method: "update",
      object: aClsToUpd[i],
      id: aClsToUpd[i].id
    });

    delete aClsToUpd[i].id;
  }

  delete opt.object.classesToIns;
  delete opt.object.classesToUpd;

  // Look for i18n object
  var i18nOpt = {
    sysuser_id: opt.sysuser_id,
    transName: transName,
    object: opt.object.i18n
  };

  delete opt.object.i18n;

  /* Function to execute */
  var aFunc = {
    update: function(cb) {wgLegend.super_.prototype.update.call(self,opt,cb);},
    insCls: function(cb) {async.each(aInsCls,manageClass,cb);},
    updCls: function(cb) {async.each(aUpdCls,manageClass,cb);},
    insI18N: function(cb) {manageI18N(i18nOpt,"upsertWoId",cb);}
  };

  /* Execute */
  if (bDoTrans)
  {
    // Begin transaction
    self.crud.beginTransaction(transName,function(btErr)
    {
      if (btErr)
      {
        callback(btErr,null);
        return;
      }

      // Exec function
      async.parallelLimit(aFunc,1,function(err,res)
      {
        if (err)
        {
          self.crud.rollbackTransaction(transName,function(rtErr){});
          callback(err,null);
          return;
        }

        // Commit transaction
        self.crud.commitTransaction(transName,function(ctErr)
        {
          callback(ctErr,ctErr ? null : res.update);
        });
      });
    });
  }
  else
  {
    async.parallelLimit(aFunc,1,function(err,res)
    {
      callback(err,err ? null : res.update);
    });
  }
}

wgLegend.prototype.delete = function(opt,callback)
{
  var transOpt = {fake:true, name:opt.transName};

  if (!opt.transName)
  {
    opt.transName = "DeleteLegend_" + new Date().getTime();
    transOpt.fake = false;
    transOpt.name = opt.transName;
  }

  // Begin transaction
  beginTransaction(transOpt,function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // Get classes for given legend
    var qVal = [{value: opt.id}];
    var qOpt =
    {
      queryName: "ClassesForLegend",
      transName: transOpt.name,
      fields: [{name:"id"}],
      from: [{
        schema: self.schemaName,
        name: "wg_legend_class",
        type: self.crudUtils.TABLE
      }],
      where: [{
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "id_legend",
        operator: self.crudUtils.EQ,
        rightSide: "$1"}]
    };

    self.crud.select(qOpt,qVal,function(clErr,clRes)
    {
      if (clErr)
      {
        rollbackTransaction(transOpt);
        callback(clErr,null);
        return;
      }

      // Delete retrieve classes
      var aClsToDel = [];

      for (var i = 0;i < clRes.result.length;i++)
        aClsToDel.push({
          sysuser_id: opt.sysuser_id,
          transName: transOpt.name,
          method: "delete",
          id: clRes.result[i].id
        });

      async.each(aClsToDel,manageClass,function(delClErr)
      {
        if (delClErr)
        {
          rollbackTransaction(transOpt);
          callback(delClErr,null);
          return;
        }

        // Delete legend
        wgLegend.super_.prototype.delete.call(self,opt,function(err,res)
        {
          if (err)
          {
            rollbackTransaction(transOpt);
            callback(err,null);
            return;
          }

          // Delete i18n entry
          var i18nOpt = {
            sysuser_id: opt.sysuser_id,
            transName: transOpt.name,
            object: {label_key: res.result.label}
          };

          manageI18N(i18nOpt,"deleteWoId",function(i18nErr)
          {
            if (i18nErr)
            {
              rollbackTransaction(transOpt);
              callback(i18nErr,null);
              return;
            }

            // Commit transaction
            commitTransaction(transOpt,function(ctErr)
            {
              callback(ctErr,ctErr ? null : res);
            });
          });
        });
      });
    });
  });
}

/*
 * New method.
 */
wgLegend.prototype.getConfig = function(opt,callback)
{
  /* Get master */
  self.master(opt,function(err,res)
  {
    if (err)
    {
      callback(err,null);
      return;
    }

    /* Get legend class config */
    var lcEntity = self.entityHolder.getEntity("wgLegendClass");
    if (!lcEntity)
    {
      callback({message:"Cannot retrieve wgLegendClass entity"},null);
      return;
    }

    lcEntity.getConfig(opt,function(lcErr,lcRes)
    {
      // Ignore error
      if (!lcRes)
        lcRes = {};

      /* Prepare response */
      var retObj = {};

      for (var i = 0;i < res.result.length;i++)
      {
        var obj = res.result[i],
          key = obj.id_layer;

        // Add classes, if any
        if (lcRes[obj.id])
          obj.classes = lcRes[obj.id];

        // Add legend object to retObj
        retObj[key] = obj;
      }

      callback(null,retObj);
    });
  });
}

wgLegend.prototype.image = function(opt,callback)
{
  if (!opt.id)
  {
    callback({message:"Missing legend id"},null);
    return;
  }

  // Get image from db
  var qOpt = {
    fields: [{name: "image"}],
    from: [{
      schema: self.schemaName,
      name: self.tableName,
      type: self.crudUtils.TABLE
    }],
    where: [{
      typeCond: self.crudUtils.SIMPLE_COND,
      leftSide: "id",
      operator: self.crudUtils.EQ,
      rightSide: "$1"}]
  };
  var qVal = [{value: opt.id}];

  self.crud.select(qOpt,qVal,function(err,res)
  {
    if (err || !res.result || !res.result.length || !res.result[0].image)
    {
      callback(null,null);
      return;
    }

    callback(null,new Buffer(res.result[0].image,"base64"));
  });
}

wgLegend.prototype.upsert = function(opt,callback)
{
  var obj = opt.object;

  if (!obj || !obj.id)
  {
    callback({message:"Missing object or object id"},null);
    return;
  }

  // Look for existing object
  var qVal = [{value: obj.id}];
  var qOpt =
  {
    queryName: "ExistingLegend",
    transName: opt.transName,
    fields: [{name:"id"}],
    from: [{
      schema: self.schemaName,
      name: self.tableName,
      type: self.crudUtils.TABLE
    }],
    where: [{
      typeCond: self.crudUtils.SIMPLE_COND,
      leftSide: "id",
      operator: self.crudUtils.EQ,
      rightSide: "$1"}]
  };

  self.crud.select(qOpt,qVal,function(err,res)
  {
    if (err)
    {
      callback(err,null);
      return;
    }

    if (res.result && res.result.length)
    {
      // Update
      opt.id = opt.object.id;
      delete opt.object.id;

      self.update(opt,callback);
    }
    else
    {
      // Insert
      self.insert(opt,callback);
    }
  });
}

/*
 * Export.
 */
exports.wgLegend = wgLegend;

/*
 * Private function.
 */
function manageI18N(opt,method,callback)
{
  if (!opt.object || !opt.object.label_key)
  {
    callback(null);
    return;
  }

  // Get i18n entity
  var entity = self.entityHolder.getEntity("i18n");
  if (!entity)
  {
    callback({message:"Cannot retrieve i18n entity"});
    return;
  }

  // Exec
  entity[method](opt,function(err,res)
  {
    callback(err);
  });
}

function manageClass(obj,callback)
{
  var entity = self.entityHolder.getEntity("wgLegendClass");
  var method = obj.method;

  if (!entity)
  {
    callback({message:"Cannot retrieve wgLegendClass entity"});
    return;
  }

  // Exec method
  entity[method](obj,function(err,res)
  {
    callback(err);
  });
}

function beginTransaction(opt,callback)
{
  if (opt.fake)
    callback(null);
  else
    self.crud.beginTransaction(opt.name,callback);
}

function commitTransaction(opt,callback)
{
  if (opt.fake)
    callback(null);
  else
    self.crud.commitTransaction(opt.name,callback);
}

function rollbackTransaction(opt)
{
  if (!opt.fake)
    self.crud.rollbackTransaction(opt.name,function(err){});
}
