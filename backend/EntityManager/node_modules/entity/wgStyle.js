/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var crut = require("../../lib/crudUtils");
var fs = require("fs");

/*
 * wgStyle class
 */
var wgStyle = function(schema)
{
  this.modName = "Entity wgStyle";
  this.dbSchema = schema;
  this.template = {};
}

wgStyle.prototype.init = function(opt)
{
  this.log = opt.log;
  this.crud = opt.crud;
}

wgStyle.prototype.polygonSLD = function(opt,callback)
{
  var self = this;

  /*
   * Load layer style:
   *
   * if there is user_id in queryString, then layer has a user style and we
   * read it from user_layer_style table;
   * otherwise we read layer style from wg_layer table
   */

  var tableName = opt.object.user_id ? "user_layer_style" : "wg_layer";

  var whereCond = opt.object.user_id ?
    [{
      typeCond: crut.SIMPLE,
      leftSide: "layer_id",
      operator: crut.EQ,
      rightSide: "$1",
      nextCond: crut.AND
    },{
      typeCond: crut.SIMPLE,
      leftSide: "user_id",
      operator: crut.EQ,
      rightSide: "$2"
    }] :
    [{
      typeCond: crut.SIMPLE,
      leftSide: "id",
      operator: crut.EQ,
      rightSide: "$1"
    }];

  var qOpt = {
    fields: [{name: "style"}],
    from: [{schema:self.dbSchema, name:tableName, type:crut.TABLE}],
    where: whereCond
  };

  var qVal = [{value:opt.object.layer_id}];

  if (opt.object.user_id)
    qVal.push({value:opt.object.user_id});

  self.crud.select(qOpt,qVal,function(err,res)
  {
    if (err || !res || !res.result || !res.result[0])
    {
      callback(null,"");
      return;
    }

    /* Process style */
    var style = res.result[0].style || {};
    var sld = "";

    switch (style.type)
    {
      case 1: sld = polySLD1(self,style); break;
      case 2: sld = polySLD2(self,style); break;
      case 3: sld = polySLD3(self,style); break;
      default: break;
    }

    callback(null,sld);
  });
}

wgStyle.prototype.loadTemplate = function(name)
{
  if (!this.template[name])
  {
    try
    {
      var path = __dirname + "/../../template/";

      this.template[name] = fs.readFileSync(path+name,"utf8");
    }
    catch (err)
    {
      this.log.error(this.modName+" - Cannot load template: "+err.message);
    }
  }

  return this.template[name];
}

exports.wgStyle = wgStyle;

/*
 * Function used to build sld tag
 */
function tagText(entity,obj)
{
  if (!obj || !obj.text)
    return "";

  /* Load template */
  var text = entity.loadTemplate("tag-text.sld") || "";

  /* Process label */
  var label = "";

  for (var j = 0;j < obj.text.length;j++)
  {
    var c = obj.text.charAt(j);

    if (c == "$" && obj.text.charAt(j+1) == "{")
    {
      label += "<PropertyName>";
      j++;
    }
    else if (c == "}")
      label += "</PropertyName>";
    else
      label += c;
  }

  text = text.replace("${label}",label);

  /* Process font/color */
  text = text.replace("${fontSize}",obj.fontSize || 11);

  text = text.replace("${textColor}",colorWoAlpha(
    obj.textColor || "#000000"));

  text = text.replace("${textBackColor}",colorWoAlpha(
    obj.textBackColor || "#ffffff"));

  /* Ok */
  return text;
}

function tagFill(entity,obj)
{
  var fill = entity.loadTemplate(obj.id == 1 ?
    "tag-fill-fill.sld" : "tag-fill-shape.sld") || "";

  fill = fill.replace("${shape}",shapeForId(obj.id));
  fill = fill.replace("${color}",colorWoAlpha(obj.color));

  return fill;
}

function tagStroke(entity,obj)
{
  var stroke = "";

  if (obj.strokeWidth || obj.strokeColor)
  {
    stroke = entity.loadTemplate("tag-stroke.sld") || "";

    stroke = stroke.replace("${strokeWidth}",obj.strokeWidth || 1);
    stroke = stroke.replace("${strokeColor}",colorWoAlpha(
      obj.strokeColor || obj.color));
  }

  return stroke;
}

function tagFilterCond(entity,obj)
{
  var filter = "";

  if (obj && obj.op && obj.name && obj.value)
  {
    var value = obj.value,
      wildCard = "";

    if (obj.op == "ILIKE")
    {
      value = "%"+value+"%";
      wildCard = " wildCard=\"%\" singleChar=\".\" escape=\"\\\"";
    }

    /* Create tag */
    filter = entity.loadTemplate("tag-filter-cond.sld") || "";

    filter = filter.replace("${op}",operatorForId(obj.op)+wildCard);
    filter = filter.replace("/${op}","/"+operatorForId(obj.op));
    filter = filter.replace("${name}",obj.name);
    filter = filter.replace("${value}",value);
  }

  return filter;
}

/*
 * Private function
 */
function polySLD1(entity,style)
{
  var sld = entity.loadTemplate("sld.sld");
  var rule = style.rules ? style.rules[0] : null;
  var symbol = rule ? rule.symbol : null;

  if (!sld || !symbol)
    return "";

  var rule = [
    "<Rule>",
    "<PolygonSymbolizer>",
    tagFill(entity,symbol),
    tagStroke(entity,symbol),
    "</PolygonSymbolizer>",
    tagText(entity,style.label),
    "</Rule>"
  ].join("");

  return sld.replace("${RULES}",rule);
}

function polySLD2(entity,style)
{
  var sld = entity.loadTemplate("sld.sld");
  var rules = style.rules || [];

  if (!sld || !rules.length)
    return "";

  /* Create sld rules */
  var aRule = [];

  for (var j = 0;j < rules.length;j++)
  {
    var rule = rules[j],
      cond = rule.conditions ? rule.conditions[0] : null;

    aRule.push([
      "<Rule>",
      "<PolygonSymbolizer>",
      tagFill(entity,rule.symbol),
      tagStroke(entity,rule.symbol),
      "</PolygonSymbolizer>",
      tagText(entity,style.label),
      "<Filter>",
      tagFilterCond(entity,cond),
      "</Filter>",
      "</Rule>"
    ].join(""));
  }

  return sld.replace("${RULES}",aRule.join(""));
}

function polySLD3(entity,style)
{
  var sld = entity.loadTemplate("sld.sld");
  var rules = style.rules || [];

  if (!sld || !rules.length)
    return "";

  /* Create sld rules */
  var aRule = [];

  for (var j = 0;j < rules.length;j++)
  {
    var rule = rules[j], opName = operatorForId(rule.op),
      aCond = rule.conditions || [], aCondTag = [];

    for (var i = 0;i < aCond.length;i++)
      aCondTag.push(tagFilterCond(entity,aCond[i]));

    aRule.push([
      "<Rule>",
      "<PolygonSymbolizer>",
      tagFill(entity,rule.symbol),
      tagStroke(entity,rule.symbol),
      "</PolygonSymbolizer>",
      tagText(entity,style.label),
      "<Filter>",
      "<",opName,">",
      aCondTag.join(""),
      "</",opName,">",
      "</Filter>",
      "</Rule>"
    ].join(""));
  }

  return sld.replace("${RULES}",aRule.join(""));
}

function shapeForId(id)
{
  switch (id)
  {
    case 2: return "horline";
    case 3: return "vertline";
    case 4: return "slash";
    case 5: return "backslash";
    case 6: return "dot";
    case 7: return "plus";
    case 8: return "times";
  }

  return "";
}

function operatorForId(id)
{
  switch (id)
  {
    case "EQ": return "PropertyIsEqualTo";
    case "NE": return "PropertyIsNotEqualTo";
    case "GT": return "PropertyIsGreaterThan";
    case "GE": return "PropertyIsGreaterThanOrEqualTo";
    case "LT": return "PropertyIsLessThan";
    case "LE": return "PropertyIsLessThanOrEqualTo";
    case "ILIKE": return "PropertyIsLike";
    case "ISNULL": return "PropertyIsNull";
    case "BETWEEN": return "PropertyIsBetween";
    case "AND": return "And";
    case "OR": return "Or";
  }

  return "ND";
}

function colorWoAlpha(col)
{
  if (col && col.length >= 9)
    return col.slice(0,7);

  return col;
}
