/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entityTemplate = require("../../lib/entityTemplate").entityTemplate;
var crypto = require("crypto");
var async = require("async");
var util = require("util");
var self = {};

// macro to manage user chek uniqueness
var _EXISTING_USERNAME = "EXISTING_USERNAME";

var user = function(schema)
{
  user.super_.call(this);

  this.moduleName = "Entity.user";
  this.entityName = "user";
  this.schemaName = schema;

  this.fieldTypeObj =
  {
    creation_date: this.crudUtils.TIMESTAMP,
    remove_date: this.crudUtils.TIMESTAMP,
    birth_date: this.crudUtils.TIMESTAMP
  };
  this.masterFieldObj =
  [
    {name:"id"},
    {name:"name"},
    {name:"surname"},
    {name:"enabled"},
    {name:"username"}
  ];
  this.detailFieldObj = null;

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;

  this.retFieldObj =
  [
    {name: this.entityId},
    {name: "username", alias: "pk"}
  ];

  // sysuser entity has logical delete, but the reading is done from a view
  // that contains only not deleted records
  this.hasLogicalDelete = false;
}

/*
 * Inheritance
 */
util.inherits(user,entityTemplate);

user.prototype.init = function(options)
{
  // Store this object
  self = this;

  // Init parent
  user.super_.prototype.init.call(self, options);
}

/*
 * Reimplemented functions
 */
user.prototype.count = function(params, callback)
{
  this.tableName  = "view_sysuser";

  user.super_.prototype.count.call(self,params,function(err,res)
  {
    return callback(err,res);
  });
}

user.prototype.master = function(params,callback)
{
  this.tableName  = "view_sysuser";

  user.super_.prototype.master.call(self,params,function(err,res)
  {
    if (err || !res.result)
      return callback(err,res);

    // Add role array to each user
    async.each(res.result,selectRoleToUser,function(errRole)
    {
      return callback(errRole,res);
    });
  });
}

user.prototype.detail = function(params,callback)
{
  this.tableName  = "view_sysuser";

  user.super_.prototype.detail.call(self,params,function(err,res)
  {
    if (err || !res.result)
      return callback(err,res);

    selectRoleToUser(res.result,function(errRole)
    {
      return callback(errRole,res);
    });
  });
}

user.prototype.insert = function(params,callback)
{
  this.tableName = "sysuser";

  var transName = "InsertUser_" + new Date().getTime();
  var sendMail = false;
  var userPwd = null;

  if (params.object)
  {
    // convert username to lowercase before to process
    params.object.username = params.object.username.toLowerCase();

    // control of username uniqueness
    checkUserName(params.object.username,function(errUN,resUN)
    {
      if (errUN || !resUN.result[0])
      {
        callback({message:_EXISTING_USERNAME},null);
      }
      else // can create new user
      {
        // generate and setting user password
        if (!params.object.signature)
        {
          userPwd = generateUserPwd();
          sendMail = true;

          params.object.signature = crypto.createHash("md5").
            update(params.object.username+userPwd).digest("hex");
        }

        // if user has roles associated store user and roles into a transaction
        if (params.object.role && params.object.role.add &&
            params.object.role.add.length)
        {
          // store in temp variable role object
          var tempRole = params.object.role;

          // remove role object from json
          delete params.object.role;

          // begin transaction
          self.crud.beginTransaction(transName,function(bgErr)
          {
            if (bgErr)
            {
              callback(bgErr,null);
              return;
            }

            // insert user
            params.transName = transName;

            user.super_.prototype.insert.call(self,params,
            function(errUser,resUser)
            {
              // error on insert user -> rollback and exit
              if (errUser)
              {
                self.crud.rollbackTransaction(transName,function(rollErr)
                {
                  callback(errUser,null);
                });
              }
              else
              {
                // success on insert user -> insert roles

                // get user id
                var userId = resUser.result[self.entityId];

                // build array of roles to cycle on
                var rolesArr = [];

                for (var idx=0; idx<tempRole.add.length; idx++)
                  rolesArr.push([userId,tempRole.add[idx],"add",transName]);

                if (rolesArr.length > 0)
                {
                  // cycle on rolesArr to insert into role_sysuser
                  async.each(rolesArr,manageRoleToUser,function(err)
                  {
                    if (err)
                    {
                      // error in async.each cycle -> rollback and exit
                      self.crud.rollbackTransaction(transName,function(rollErr)
                      {
                        callback(err,null);
                      });
                    }
                    else
                    {
                      // success on insert user roles -> exec commit
                      self.crud.commitTransaction(transName,function(comErr)
                      {
                        if (comErr)
                        {
                          callback(comErr,null);
                        }
                        else
                        {
                          //callback returned on transaction success
                          callback(err,resUser);

                          // send credentials email
                          if (sendMail)
                          {
                            sendUserPwdMail(params.object,userPwd,function(errMail)
                            {
                              if (errMail)
                                self.log.error(self.moduleName+
                                  " - send credentials email error: "+
                                  errMail.message);
                            });
                          }
                        }
                      });
                    }
                  });
                }
              }
            });
          });
        }
        else
        {
          // remove role object before insert
          delete params.object.role;

          user.super_.prototype.insert.call(self,params,function(err,res)
          {
            callback(err,res);

            // send credentials email if not insert error
            if (!err && sendMail)
            {
              sendUserPwdMail(params.object,userPwd,function(errMail)
              {
                if (errMail)
                  self.log.error(self.moduleName+
                    " - send credentials email error: "+
                    errMail.message);
              });
            }
          });
        }
      }
    });
  }
}

user.prototype.update = function(params,callback)
{
  this.tableName  = "sysuser";
  var transName = "UpdateUser_" + new Date().getTime();

  if (params.object)
  {
    if (params.object.role &&
      ((params.object.role.add && params.object.role.add.length > 0) ||
       (params.object.role.del && params.object.role.del.length > 0)))
    {
      // build array of role to cycle on
      var roleArr = [];

      for (var idx=0; idx<params.object.role.del.length; idx++)
        roleArr.push([params.id,params.object.role.del[idx],"del",transName]);

      for (var idx=0; idx<params.object.role.add.length; idx++)
        roleArr.push([params.id,params.object.role.add[idx],"add",transName]);

      if (roleArr.length > 0)
      {
        // begin transaction
        self.crud.beginTransaction(transName,function(bgErr)
        {
          if (bgErr)
          {
            callback(bgErr,null);
            return;
          }

          // cycle on roleArr to update permission_role
          async.each(roleArr,manageRoleToUser,function(err)
          {
            if (err)
            {
              // error on a statement in async.each cycle -> rollback and exit
              self.crud.rollbackTransaction(transName,function(rollErr)
              {
                callback(err,null);
              });
            }
            else
            {
              // remove role object from json
              delete params.object.role;

              if (self.funcUtils.isEmptyObject(params.object))
              {
                // there is no entity to update -> exec commit
                self.crud.commitTransaction(transName,function(comErr)
                {
                  if (comErr)
                  {
                    callback(comErr,null);
                  }
                  else
                  {
                    // callback returned on transaction success
                    var jsonToRet = {};
                    jsonToRet[self.entityId] = params.id;

                    callback(null,{result:jsonToRet});
                  }
                });
              }
              else
              {
                // update user
                params.transName = transName;

                user.super_.prototype.update.call(self,params,
                function(errUser,resUser)
                {
                  // error on update user -> rollback and exit
                  if (errUser)
                  {
                    self.crud.rollbackTransaction(transName,function(rollErr)
                    {
                      callback(errUser,null);
                    });
                  }
                  else
                  {
                    // success on update user -> exec commit
                    self.crud.commitTransaction(transName,function(comErr)
                    {
                      if (comErr)
                        callback(comErr,null);
                      else
                        callback(errUser,resUser);
                    });
                  }
                });
              }
            }
          });
        });
      }
      else
      {
        // this else should never be reached
        self.log.error(self.moduleName+
          " - error: roleArr.length = 0 -> no query executed");
      }
    }
    else
    {
      // remove role object first of update
      delete params.object.role;

      user.super_.prototype.update.call(self,params,function(err,res)
      {
        callback(err,res);
      });
    }
  }
}

user.prototype.delete = function(params,callback)
{
  this.tableName = "sysuser";
  var transName = "DeleteUser_" + new Date().getTime();

  // begin transaction
  self.crud.beginTransaction(transName,function(bgErr)
  {
    if (bgErr)
    {
      callback(bgErr,null);
      return;
    }

    // remove permission related to role
    var queryOpt = {
      queryName: "DeleteAllRolesForUser",
      transName: transName,
      table: {schema:self.schemaName, name:"role_sysuser"},
      where: [{
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "sysuser_id",
        operator: self.crudUtils.EQ,
        rightSide: "$1"
      }],
      returning:[{name:"role_id"}]
    };

    var queryVal = [{value:params.id}];

    // Exec delete role query
    self.crud.delete(queryOpt,queryVal,function(errRole,resRole)
    {
      // error on delete roles -> rollback and exit
      if (errRole)
      {
        self.crud.rollbackTransaction(transName,function(rollErr)
        {
          callback(errRole,null);
        });
      }
      else
      {
        // delete user
        params.transName = transName;

        user.super_.prototype.delete.call(self,params,function(errUser,resUser)
        {
          if (errUser)
          {
            // error on delete user -> rollback and exit
            self.crud.rollbackTransaction(transName,function(rollErr)
            {
              callback(errUser,null);
            });
          }
          else
          {
            // success on delete user -> commit
            self.crud.commitTransaction(transName,function(comErr)
            {
              if (comErr)
                callback(comErr,null);
              else
                callback(errUser,resUser);
            });
          }
        });
      }
    });
  });
}

user.prototype.logicDelete = function(params,callback)
{
  this.tableName  = "sysuser";
  var transName = "LogicDeleteUser_" + new Date().getTime();

  // begin transaction
  self.crud.beginTransaction(transName,function(bgErr)
  {
    if (bgErr)
    {
      callback(bgErr,null);
      return;
    }

    // remove roles related to user
    var queryOpt = {
      queryName: "DeleteAllRolesForUser",
      transName: transName,
      table: {schema:self.schemaName, name:"role_sysuser"},
      where: [{
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "sysuser_id",
        operator: self.crudUtils.EQ,
        rightSide: "$1"
      }],
      returning:[{name:"role_id"}]
    };

    var queryVal = [{value:params.id}];

    // Exec delete role query
    self.crud.delete(queryOpt,queryVal,function(errRole,resRole)
    {
      if (errRole)
      {
        // error on delete roles -> rollback and exit
        self.crud.rollbackTransaction(transName,function(rollErr)
        {
          callback(errRole,null);
        });
      }
      else
      {
        // logic delete user
        params.transName = transName;

        user.super_.prototype.logicDelete.call(self,params,
        function(errUser,resUser)
        {
          if (errUser)
          {
            // error on logic delete user -> rollback and exit
            self.crud.rollbackTransaction(transName,function(rollErr)
            {
              callback(errUser,null);
            });
          }
          else
          {
            // success on logic delete user -> exec commit
            self.crud.commitTransaction(transName,function(comErr)
            {
              if (comErr)
                callback(comErr,null);
              else
                // callback returned on transaction success
                callback(errUser,resUser);
            });
          }
        });
      }
    });
  });
}

// select the roles associated to a given user
function selectRoleToUser(obj,callback)
{
  var crudUtil = self.crudUtils;
  var queryVal = [{value: obj.id}];
  var queryOpt =
  {
    queryName: "RoleForUser",
    fields: [{name:"id"},{name:"name"}],
    from: [{schema:self.schemaName,name:"role_sysuser",type:crudUtil.TABLE}],
    join: [{
      type: crudUtil.TABLE,
      join: crudUtil.LEFT,
      schema: self.schemaName,
      tableName: "role",
      cond: [{
        typeCond: crudUtil.SIMPLE_COND,
        leftSide: "role_id",
        operator: crudUtil.EQ,
        rightSide: "id"
      }]
    }],
    where:
    [{
      typeCond: crudUtil.SIMPLE_COND,
      leftSide: "sysuser_id",
      operator: crudUtil.EQ,
      rightSide: "$1"
    }]
  };

  // Exec query
  self.crud.select(queryOpt,queryVal,function(err,res)
  {
    if (err)
      return callback(err);

    if (res.result)
    {
      obj.role = [];
      obj.role_name = [];

      for (var j = 0;j < res.result.length;j++)
      {
        obj.role.push(res.result[j].id);
        obj.role_name.push(res.result[j].name);
      }
    }

    callback(null);
  });
}

/*
 * Exports
 */
exports.user = user;

/*
 * Private utility functions
 */

// verify for username uniqueness on system
function checkUserName(username, callback)
{
  var crudUtil = self.crudUtils;
  var canCreateUser = true;

  var queryOpt =
  {
    fields: [{name:"id"}],
    from: [{schema:self.schemaName,name:"view_sysuser",type:crudUtil.TABLE}],
    where:
    [
      {
        typeCond: crudUtil.SIMPLE_COND,
        leftSide: "LOWER(username)",
        operator: crudUtil.EQ,
        rightSide: "$1"
      }
    ]
  };

  var queryVal = [{value:username}];

  // Exec query
  self.crud.select(queryOpt, queryVal, function(err,res)
  {
    if (err || res.result.length >= 1)
    {
      var message = err ? err.message : "";
      self.log.error(self.moduleName + " - username uniqueness check error: " + message);
      canCreateUser = false;
    }

    callback(err, {result:[canCreateUser]});
  });
}

// add and remove roles into role_sysuser entity, related to a given user
function manageRoleToUser(obj,callback)
{
  var crudUtil = self.crudUtils;
  var manageRoleUserQueryOpt = {};
  var queryVal = [];

  queryVal.push({value:obj[0]});
  queryVal.push({value:obj[1]});

  if (obj[2] == "add")
  {
    manageRoleUserQueryOpt =
    {
      queryName: "AddRoleForUser",
      transName: obj[3],
      table: {schema:self.schemaName, name:"role_sysuser"},
      fields: [
        {name:"sysuser_id"},
        {name:"role_id"}
      ],
      returning:[{name:"role_id"}]
    };

    // Exec query
    self.crud.insert(manageRoleUserQueryOpt,queryVal,function(err,res)
    {
      callback(err);
    });
  }
  else if (obj[2] == "del")
  {
    manageRoleUserQueryOpt =
    {
      queryName: "DeleteRoleForUser",
      transName: obj[3],
      table: {schema:self.schemaName, name:"role_sysuser"},
      where: [
        {
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "sysuser_id",
          operator: crudUtil.EQ,
          rightSide: "$1",
          nextCond: crudUtil.AND
        },
        {
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "role_id",
          operator: crudUtil.EQ,
          rightSide: "$2"
        }
      ],
      returning:[{name:"role_id"}]
    };

    // Exec query
    self.crud.delete(manageRoleUserQueryOpt,queryVal,function(err,res)
    {
      callback(err);
    });
  }
  else
  {
    // TODO: manage this error? Is impossible reach this else....
  }
}

// generate random user password
function generateUserPwd()
{
  var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghijklmnopqrstuvwxyz";
  var string_length = 8;
  var randomstring = '';

  for (var i=0; i<string_length; i++)
  {
      var rnum = Math.floor(Math.random() * chars.length);
      randomstring += chars.substring(rnum,rnum+1);
  }

  return randomstring;
}

// send email to user with system credentials
function sendUserPwdMail(userObj, password, callback)
{
  var jsonMailCfg =
  {
    to: userObj.email,
    subject: self.env.appName + " - Notifica credenziali di accesso al sistema",
    text: "Buongiorno "+userObj.name+" "+userObj.surname+",\n\n"+
          "di seguito le Sue credenziali per accedere al sistema:\n\n"+
          "username: "+userObj.username+"\n"+
          "password: "+password+"\n\n"+
          "web address: "+self.env.url+"\n\n\n"+
          "Saluti,\n\n\n"+
          "L'amministratore del sistema"
  }

  self.mailer.sendMail(jsonMailCfg,function(err)
  {
    return callback(err);
  });
}
