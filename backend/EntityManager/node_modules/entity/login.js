/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entityTemplate = require("../../lib/entityTemplate").entityTemplate;
var util = require("util");
var crypto = require("crypto");

var self = {};

var login = function(schema)
{
  login.super_.call(this);

  this.moduleName = "Entity.login";
  this.entityName = "login";
  this.schemaName = schema;

  this.fieldTypeObj = null;
  this.masterFieldObj = null;
  this.detailFieldObj = null;

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;

  this.retFieldObj = null;

  this.hasLogicalDelete = false;
}

/*
 * Inheritance.
 */
util.inherits(login,entityTemplate);

login.prototype.init = function(options)
{
  // Store this object
  self = this;

  // Init parent
  login.super_.prototype.init.call(self,options);
}

/*
 * Response to POST /login/doLogin.
 * The following steps are performed:
 * 1. verifies that the received signature is associated with a user
 * 2. generate token to return to the client
 * 3. write a record in session table
 */
login.prototype.doLogin = function(params,callback)
{
  if (params.object.signature)
  {
    var obj = {};
    obj.sign = params.object.signature;

    // verifies that the received signature is associated with a user
    existsUser(obj,function(err,res)
    {
      if (err)
        return callback(err,null);
      else
      {
        if (!res.enabled)
        {
          // User disabled: cannot generate token
          return callback(null,{error:"USER_DISABLED"});
        }

        // generate token
        var sessionToken = generateToken();

        // write a record in session table
        var now = new Date();

        var queryOpt =
        {
          queryName: "insertSession",
          table: {schema:self.schemaName, name:"session"},
          fields: [
            {name:"sysuser_id"},
            {name:"token"},
            {name:"login_date"},
            {name:"last_access_date"}
          ],
          fieldType:
          {
            "access_date": self.crudUtils.TIMESTAMP,
            "last_access_date": self.crudUtils.TIMESTAMP,
            "expiration_date": self.crudUtils.TIMESTAMP
          },
          returning:
          [{
            name: "id",
            leftSide: "signature",
            operator: self.crudUtils.EQ,
            rightSide: "$1"
          }]
        };

        var queryVal = [];
        queryVal.push({value:obj.id});
        queryVal.push({value:sessionToken});
        queryVal.push({value:now});
        queryVal.push({value:now});

        self.crud.insert(queryOpt, queryVal, function(errSession, resSession)
        {
          if (errSession)
          {
            self.log.error(self.moduleName + " - " +
              "Error to insert record into session table: "+ errSession.message);

            callback(errSession,null);
          }
          else
            callback(null,sessionToken);
        });
      }
    });
  }
  else
  {
    var signErr = {};
    signErr.message = "No signature provided"
    self.log.error(self.moduleName + " - " + signErr.message);
    callback(signErr,null)
  }
}

login.prototype.doLoginNew = function(opt,callback)
{
  self.doLogin(opt,function(err,res)
  {
    if (res)
      res = {result:res};

    callback(err,res);
  });
}

/*
 * Response to GET /login/userInfo
 * recover user data by session token
 */
login.prototype.userInfo = function(params,callback)
{
  if (params.token)
  {
    if (params.token.type == 'inner')
    {
      /*
        SELECT view_sysuser.* FROM view_sysuser
        LEFT JOIN session ON (view_sysuser.id = session.sysuser_id)
        WHERE (token = $1)
      */
      var queryVal = [{value: params.token.token}];
      var queryOpt =
      {
        queryName: "UserInfo",
        fields: [{name: self.schemaName + ".view_sysuser.*"}],
        from: [{
          schema: self.schemaName,
          name: "view_sysuser",
          type:self.crudUtils.TABLE
        }],
        join: [{
          type: self.crudUtils.TABLE,
          join: self.crudUtils.LEFT,
          schema: self.schemaName,
          tableName: "session",
          cond: [{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: self.schemaName + ".view_sysuser.id",
            operator: self.crudUtils.EQ,
            rightSide: self.schemaName + ".session.sysuser_id"
          }]
        }],
        where: [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "token",
          operator: self.crudUtils.EQ,
          rightSide: "$1"
        }]
      };

      // Exec query
      self.crud.select(queryOpt,queryVal,function(err,res)
      {
        if (err)
          return callback(err);

        if (res.result)
        {
          if (res.result.length == 0)
          {
            var noUserErr = {
              message: "No user founded with session token "+params.token.token
            };

            self.log.error(self.moduleName+" - "+noUserErr.message);
            callback(noUserErr,null);
          }
          else if (res.result.length > 1)
          {
            var moreErr = {
              message: "Founded more user with session token "+params.token.token
            };

            self.log.error(self.moduleName+" - "+moreErr.message);
            callback(moreErr,null);
          }
          else
          {
            // retrieve user roles
            selectRoleToUser(res.result[0],function(errR2U)
            {
              if (errR2U)
              {
                var selRoleErr = {message: "Error on found roles for user "+
                  res.result[0].username
                };

                self.log.error(self.moduleName+" - "+selRoleErr.message);
                callback(selRoleErr,null);
              }
              else
              {
                selectEventTypeToUser(res.result[0],function(errET2U)
                {
                  if (errET2U)
                  {
                    var selEventTypeErr = {message:
                      "Error on found event types for user "+res.result[0].username
                    };

                    self.log.error(self.moduleName+" - "+selEventTypeErr.message);
                    callback(selEventTypeErr,null);
                  }
                  else
                  {
                    self.log.info(self.moduleName+" - Founded user with id: "+
                      res.result[0].id);
                    callback(null,{result: res.result[0]});
                  }
                });
              }
            });
          }
        }
      });
    }
    else if (params.token.type == 'bearer')
    {
      /*
        SELECT view_sysuser.* FROM view_sysuser
        WHERE (tax_code = $1)
      */
      var queryVal = [{value: params.taxCode}];
      var queryOpt =
      {
        queryName: "UserInfo",
        fields: self.crudUtils.ALL_FIELDS,
        from: [{
          schema: self.schemaName,
          name: "view_sysuser",
          type:self.crudUtils.TABLE
        }],
        where: [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "tax_code",
          operator: self.crudUtils.EQ,
          rightSide: "$1"
        }]
      };

      // Exec query
      self.crud.select(queryOpt,queryVal,function(err,res)
      {
        if (err)
          return callback(err,null);

        if (res.result)
        {
          if (res.result.length == 0)
          {
            var noUserErr = {
              message: "No user founded with tax_code " + params.taxCode
            };

            self.log.error(self.moduleName + " - " + noUserErr.message);
            callback(noUserErr,null);
          }
          else if (res.result.length > 1)
          {
            var moreErr = {
              message: "Founded more user with tax_code " + params.taxCode
            };

            self.log.error(self.moduleName + " - " + moreErr.message);
            callback(moreErr,null);
          }
          else
          {
            // retrieve user roles
            selectRoleToUser(res.result[0],function(errR2U)
            {
              if (errR2U)
              {
                var selRoleErr = {message: "Error on found roles for user " +
                  res.result[0].username
                };

                self.log.error(self.moduleName + " - " + selRoleErr.message);
                callback(selRoleErr,null);
              }
              else
              {
                selectEventTypeToUser(res.result[0],function(errET2U)
                {
                  if (errET2U)
                  {
                    var selEventTypeErr = {message:
                      "Error on found event types for user " + res.result[0].username
                    };

                    self.log.error(self.moduleName + " - " + selEventTypeErr.message);
                    callback(selEventTypeErr,null);
                  }
                  else
                  {
                    self.log.info(self.moduleName + " - Founded user with id: " +
                      res.result[0].id);
                    callback(null,{result: res.result[0]});
                  }
                });
              }
            });
          }
        }
      });
    }
    else
    {
      var tokErr = {message: "authentication token type wrong!"};

      self.log.error(self.moduleName + " - " + tokErr.message);
      callback(tokErr,null);
    }
  }
  else
  {
    var tokErr = {message: "No token provided"};

    self.log.error(self.moduleName + " - " + tokErr.message);
    callback(tokErr,null);
  }
}

/*
 * Response to POST /auth/getToken
 * verify given user and password and return token to use in every subsequent request
 */
login.prototype.getToken = function(params,callback)
{
  if (params.object.user && params.object.auth)
  {
    // retrieve signature
    var signature =
      crypto.createHash("md5").update(params.object.user+params.object.auth).digest("hex");

    params.object.signature = signature;
    delete params.object.user;
    delete params.object.auth;

    // invoke doLogin method
    self.doLogin(params,function(err,res)
    {
      if (res)
        res = {result:res};

      if (err)
        err = {message:"No user found with given username and password!"};

      callback(err,res);
    });
  }
  else
  {
    var signErr = {};
    signErr.message = "No rights params provided!"
    self.log.error(self.moduleName + " - " + signErr.message);
    callback(signErr,null)
  }
}

/*
 * Exports
 */
exports.login = login;

/*
 * Private utility functions
 */

// verify user presence associated to the signature
function existsUser(obj,callback)
{
  var crudUtil = self.crudUtils;
  var queryVal = [{value: obj.sign}];
  var queryOpt =
  {
    queryName: "existsUser",
    fields: [{name:"id"},{name:"enabled"}],
    from: [{schema:self.schemaName,name:"view_sysuser",type:crudUtil.TABLE}],
    where:
    [{
      typeCond: crudUtil.SIMPLE_COND,
      leftSide: "password",
      operator: crudUtil.EQ,
      rightSide: "$1"
    }]
  };

  // Exec query
  self.crud.select(queryOpt,queryVal,function(err,res)
  {
    if (err)
      return callback(err,null);

    if (res.result)
    {
      if (res.result.length == 0)
      {
        var noUserErr = {};
        noUserErr.message = "No user founded with signature " + obj.sign;
        self.log.error(self.moduleName + " - " + noUserErr.message);
        return callback(noUserErr,null);
      }
      else if (res.result.length > 1)
      {
        var moreErr = {};
        moreErr.message = "Founded more than one user with signature " + obj.sign;
        self.log.error(self.moduleName + " - " + moreErr.message);
        return callback(moreErr,null);
      }
      else
      {
        obj.id = res.result[0].id;
        self.log.info(self.moduleName + " - Found user with id: " + obj.id);
        callback(null,res.result[0]);
      }
    }
  });
}

// Generate a token as a random string 32 char length
function generateToken()
{
  var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  var string_length = 32;
  var token = "";

  for (var i=0; i<string_length; i++)
  {
    var rnum = Math.floor(Math.random() * chars.length);
    token += chars.substring(rnum,rnum+1);
  }

  return token;
}

// select the roles associated to a given user
function selectRoleToUser(obj, callback)
{
  /*
   * SELECT id, name FROM role_sysuser LEFT JOIN role ON (role_id = id) WHERE (sysuser_id = $1)
   */
  var crudUtil = self.crudUtils;
  var queryVal = [{value: obj.id}];
  var queryOpt =
  {
    queryName: "RolesForUser",
    fields: [{name:"id"},{name:"name"}],
    from: [{schema:self.schemaName,name:"role_sysuser",type:crudUtil.TABLE}],
    join:
    [{
      type: crudUtil.TABLE,
      join: crudUtil.LEFT,
      schema: self.schemaName,
      tableName: "role",
      cond:
        [{
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "role_id",
          operator: crudUtil.EQ,
          rightSide: "id"
        }]
    }],
    where:
    [{
      typeCond: crudUtil.SIMPLE_COND,
      leftSide: "sysuser_id",
      operator: crudUtil.EQ,
      rightSide: "$1"
    }]
  };

  // Exec query
  self.crud.select(queryOpt, queryVal, function(err,res)
  {
    if (err)
      return callback(err);

    obj.role = res.result;
    callback(null);
  });
}

// select the event types associated to a given user
// Must return also event types that are not related to any permission
function selectEventTypeToUser(obj, callback)
{
  /*
   * SELECT id,name FROM event_type
   * LEFT JOIN event_type_permission ON (event_type_id = id)
   * WHERE (permission_id IN (
   *  SELECT id FROM permission
   *  LEFT JOIN permission_role ON (permission_id = id)
   *  WHERE (role_id = 4))
   * )
   * UNION
   * SELECT id,name FROM event_type
   * WHERE id NOT IN (SELECT event_type_id FROM event_type_permission)
   */

  var crudUtil = self.crudUtils;
  var params   = [];
  var queryVal = [];

  if (obj.role && obj.role.length >0)
  {
    for (var i=0; i<obj.role.length; i++)
    {
      params.push('$'+(i+1));
      queryVal.push({value:obj.role[i].id});
    }
  }

  var queryOpt =
  {
    queryName: "EventTypesForUser",
    fields: [{name:"id"},{name:"name"}],
    from: [{schema:self.schemaName,name:"event_type",type:crudUtil.TABLE}],
    join:
    [{
      type: crudUtil.TABLE,
      join: crudUtil.LEFT,
      schema: self.schemaName,
      tableName: "event_type_permission",
      cond:
        [{
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "event_type_id",
          operator: crudUtil.EQ,
          rightSide: "id"
        }]
    }],
    where:
    [{
      typeCond: crudUtil.SUBQUERY_COND,
      leftSide: "permission_id",
      operator: crudUtil.IN,
      rightSide:
      {
        fields: [{name:"id"}],
        from: [{schema:self.schemaName,name:"permission",type:crudUtil.TABLE}],
        join:
        [{
          type: crudUtil.TABLE,
          join: crudUtil.LEFT,
          schema: self.schemaName,
          tableName: "permission_role",
          cond:
            [{
              typeCond: crudUtil.SIMPLE_COND,
              leftSide: "permission_id",
              operator: crudUtil.EQ,
              rightSide: "id"
            }]
        }],
        where:
        [{
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "role_id",
          operator: crudUtil.IN,
          rightSide: params.join(",")
        }]
      }
    }],
    union:
    [{
      fields: [{name:"id"},{name:"name"}],
      from: [{schema:self.schemaName,name:"event_type",type:crudUtil.TABLE}],
      where:
      [{
        typeCond: crudUtil.SUBQUERY_COND,
        leftSide: "id",
        operator: crudUtil.NOT_IN,
        rightSide:
        {
          fields: [{name:"event_type_id"}],
          from: [{
            schema: self.schemaName,
            name: "event_type_permission",
            type: crudUtil.TABLE
          }],
        }
      }]
    }]
  };

  // Exec query
  self.crud.select(queryOpt, queryVal, function(err,res)
  {
    if (err)
      return callback(err);

    if (res.result && res.result.length)
    {
      obj.event_type = [];

      for (var i=0; i<res.result.length; i++)
        obj.event_type.push(res.result[i].name);
    }

    callback(null);
  });
}
