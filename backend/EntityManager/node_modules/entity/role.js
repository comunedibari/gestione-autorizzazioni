/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entityTemplate = require("../../lib/entityTemplate").entityTemplate;
var async = require("async");
var util = require("util");
var self = {};

var role = function(schema)
{
  role.super_.call(this);

  this.moduleName = "Entity.role";
  this.entityName = "role";
  this.schemaName = schema;
  this.tableName  = "role";

  this.fieldTypeObj =
  {
    creation_date: this.crudUtils.TIMESTAMP,
    remove_date: this.crudUtils.TIMESTAMP
  };
  this.masterFieldObj =
  [
    {name: "id"},
    {name: "name"},
    {name: "descr"},
    {name: "readonly"}
  ];
  this.detailFieldObj = null;

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;

  this.retFieldObj =
  [
    {name: this.entityId},
    {name: "name", alias: "pk"}
  ];

  this.hasLogicalDelete = true;
}

/*
 * Inheritance.
 */
util.inherits(role,entityTemplate);

role.prototype.init = function(options)
{
  self = this;
  role.super_.prototype.init.call(self,options);
}

/*
 * Reimplemented functions.
 */
role.prototype.master = function(params,callback)
{
  role.super_.prototype.master.call(self,params,function(err,res)
  {
    if (err || !res.result)
      return callback(err,res);

    // if is defined simple parameter, the master not contains permissions array
    if (params.object.simple)
      return callback(err,res);

    // Add permission array to each role
    async.each(res.result, selectPermissionToRole, function(err)
    {
      return callback(err,res);
    });
  });
}

role.prototype.detail = function(params,callback)
{
  role.super_.prototype.detail.call(self,params,function(err,res)
  {
    if (err || !res.result)
      return callback(err,res);

    selectPermissionToRole(res.result,function(err)
    {
      return callback(err,res);
    });
  });
}

role.prototype.insert = function(params,callback)
{
  var transactionName = "InsertRole_" + new Date().getTime();

  if (params.object)
  {
    if (params.object.permission && params.object.permission.add &&
      params.object.permission.add.length)
    {
      // store in temp variable permission object
      var tempPerm = params.object.permission;

      // remove permission object from json
      delete params.object.permission;

      // begin transaction
      self.crud.beginTransaction(transactionName,function(bgErr)
      {
        if (bgErr)
        {
          callback(bgErr,null);
          return;
        }

        // insert role
        params.transName = transactionName;

        role.super_.prototype.insert.call(self,params,function(errRole,resRole)
        {
          // error on insert role -> exec rollback
          if (errRole)
          {
            self.crud.rollbackTransaction(transactionName,function(rollErr)
            {
              callback(errRole,null);
            });
          }
          else
          {
            // success on insert role -> insert permissions related to role

            // get role id
            var roleId = resRole.result[self.entityId];

            // build array of permissions to cycle on
            var permArr = [];

            for (var idx=0; idx<tempPerm.add.length; idx++)
              permArr.push([roleId,tempPerm.add[idx],"add",transactionName]);

            if (permArr.length > 0)
            {
              // cycle on permArr to insert into permission_role
              async.each(permArr,managePermissionToRole,function(err)
              {
                if (err)
                {
                  // error on a statement in async.each cycle -> exec rollback
                  self.crud.rollbackTransaction(transactionName,function(rolErr)
                  {
                    callback(err,null);
                  });
                }
                else
                {
                  // success on insert permission_role -> exec commit
                  self.crud.commitTransaction(transactionName,function(comErr)
                  {
                    if (comErr)
                      // callback returned on commit error
                      callback(comErr,null);
                    else
                      // callback returned on transaction success
                      callback(null,resRole);
                  });
                }
              });
            }
          }
        });
      });
    }
    else
    {
      // remove permission object first of insert
      delete params.object.permission;

      role.super_.prototype.insert.call(self,params,function(err,res)
      {
        callback(err,res);
      });
    }
  }
}

role.prototype.update = function(params, callback)
{
  var transactionName = "UpdateRole_" + new Date().getTime();

  if (params.object)
  {
    if (params.object.permission &&
      ((params.object.permission.add && params.object.permission.add.length) ||
       (params.object.permission.del && params.object.permission.del.length)))
    {
      // build arrays of permissions to cycle on
      var permToDelArr = [];
      var permToAddArr = [];

      for (var idx=0; idx<params.object.permission.add.length; idx++)
        permToAddArr.push([
          params.id*1,
          params.object.permission.add[idx],
          "add",transactionName]);

      for (var idx=0; idx<params.object.permission.del.length; idx++)
        permToDelArr.push([
          params.id*1,
          params.object.permission.del[idx],
          "del",transactionName]);

      var permArr = permToAddArr.concat(permToDelArr);

      if (permArr.length > 0)
      {
        // begin transaction
        self.crud.beginTransaction(transactionName,function(bgErr)
        {
          if (bgErr)
          {
            callback(bgErr,null);
            return;
          }

          // cycle on permArr to update permission_role
          async.each(permArr,managePermissionToRole,function(errPermRole)
          {
            if (errPermRole)
            {
              // error on a statement in async.each cycle -> exec rollback
              self.crud.rollbackTransaction(transactionName,function(rollErr)
              {
                callback(errPermRole,null);
              });
            }
            else
            {
              // succesfully modified permission role -> update role

              // remove permission object from json
              delete params.object.permission;

              if (self.funcUtils.isEmptyObject(params.object))
              {
                // there is no entity to update -> exec commit
                self.crud.commitTransaction(transactionName,function(comErr)
                {
                  if (comErr)
                    callback(comErr,null);
                  else
                    callback(null,{result: {[self.entityId]: params.id}});
                });
              }
              else
              {
                params.transName = transactionName;

                // update role
                role.super_.prototype.update.call(self,params,function(errRole,resRole)
                {
                  if (errRole)
                  {
                    // error on update role -> exec rollback
                    self.crud.rollbackTransaction(transactionName,function(rolErr)
                    {
                      callback(errRole,null);
                    });
                  }
                  else
                  {
                    // success on update role -> exec commit
                    self.crud.commitTransaction(transactionName,function(comErr)
                    {
                      if (comErr)
                        callback(comErr,null);
                      else
                        callback(errRole,resRole);
                    });
                  }
                });
              }
            }
          });
        });
      }
      else
        // this else should never be reached
        self.log.error(self.moduleName+
          " - error: permArr.length = 0 -> no query executed");
    }
    else
    {
      // remove permission object first of update
      delete params.object.permission;

      role.super_.prototype.update.call(self,params,function(err,res)
      {
        callback(err,res);
      });
    }
  }
}

role.prototype.delete = function(params,callback)
{
  /*
   * check that there are no active users associated with the role to be deleted
   *
   * Query to execute:
   *
   * SELECT id FROM view_sysuser vs
   * LEFT JOIN role_sysuser rs ON vs.id = rs.sysuser_id
   * WHERE rs.role_id = <role_id>
   */
  var verifyUserQueryOpt =
  {
    queryName: "verifyUserForRole",
    fields: [{name:"id"}],
    from: [{
      schema: self.schemaName,
      name: "view_sysuser",
      type: self.crudUtils.TABLE,
      alias: "vs"
    }],
    join:
    [{
      type: self.crudUtils.TABLE,
      join: self.crudUtils.LEFT,
      schema: self.schemaName,
      tableName: "role_sysuser",
      alias: "rs",
      cond:
        [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "vs.id",
          operator: self.crudUtils.EQ,
          rightSide: "rs.sysuser_id"
        }]
    }],
    where:
    [
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "rs.role_id",
        operator: self.crudUtils.EQ,
        rightSide: "$1"
      }
    ],
    returning:[{name:"vs.id"}]
  };

  var verifyUserQueryVal = [];
  verifyUserQueryVal.push({value:params.id});

  // exec select
  self.crud.select(verifyUserQueryOpt,verifyUserQueryVal,function(errVer,resVer)
  {
    if (errVer)
    {
      // error on select -> exit to delete
      self.log.error(self.moduleName+
        " - Verify presence of users with given role error: "+errVer.message);

      callback(errVer,null);
    }
    else if (resVer.result.length > 0)
    {
      // there are active users (one or more) with given role:
      // notify and exit to delete
      var strInfoMsg = "";

      for (var idx=0; idx<resVer.result.length; idx++)
      {
        strInfoMsg += resVer.result[idx].id;

        if (idx < resVer.result.length-1)
          strInfoMsg += ", ";
      }

      self.log.info(self.moduleName+
        " - Exist users with associated role to delete: "+strInfoMsg);

      callback({message:1},null);
    }
    else
    {
      // no active user with that role -> proceed with delete
      deleteRole(params,callback);
    }
  });
}

role.prototype.logicDelete = function(params,callback)
{
  /*
   * check that there are no active users associated with the role to be deleted
   *
   * Query to execute:
   *
   * SELECT id FROM view_sysuser vs
   * LEFT JOIN role_sysuser rs ON vs.id = rs.sysuser_id
   * WHERE rs.role_id = <role_id>
   */
  var verifyUserQueryOpt =
  {
    queryName: "verifyUserForRole",
    fields: [{name:"id"}],
    from: [{
      schema: self.schemaName,
      name: "view_sysuser",
      type: self.crudUtils.TABLE,
      alias:"vs"
    }],
    join: [{
      type: self.crudUtils.TABLE,
      join: self.crudUtils.LEFT,
      schema: self.schemaName,
      tableName: "role_sysuser",
      alias: "rs",
      cond:
        [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "vs.id",
          operator: self.crudUtils.EQ,
          rightSide: "rs.sysuser_id"
        }]
    }],
    where:
    [{
      typeCond: self.crudUtils.SIMPLE_COND,
      leftSide: "rs.role_id",
      operator: self.crudUtils.EQ,
      rightSide: "$1"
    }],
    returning:[{name:"vs.id"}]
  };

  var verifyUserQueryVal = [{value:params.id}];

  // exec select
  self.crud.select(verifyUserQueryOpt,verifyUserQueryVal,function(errVer,resVer)
  {
    if (errVer)
    {
      // error on select -> exit to logic delete
      self.log.error(self.moduleName+
        " - Verify presence of users with given role error: "+errVer.message);

      callback(errVer,null);
    }
    else if (resVer.result.length > 0)
    {
      // there are active users (one or more) with given role:
      // notify and exit to logic delete
      var strInfoMsg = "";

      for (var idx=0; idx<resVer.result.length; idx++)
      {
        strInfoMsg += resVer.result[idx].id;

        if (idx < resVer.result.length-1)
          strInfoMsg += ", ";
      }

      self.log.info(self.moduleName+
        " - Exist users with associated role to delete: "+strInfoMsg);

      callback({message:1},null);
    }
    else
    {
      // no active user with that role -> proceed with logic delete
      logicDeleteRole(params,callback);
    }
  });
}

/*
 * Exports
 */
exports.role = role;

/*
 * Private utility functions.
 */

// select the permission associated to a given role
function selectPermissionToRole(obj,callback)
{
  var crudUtil = self.crudUtils;
  var queryVal = [{value: obj.id}];
  var queryOpt =
  {
    queryName: "PermissionForRole",
    fields: [{name:"id"}],
    from: [{schema:self.schemaName,name:"permission_role",type:crudUtil.TABLE}],
    join: [{
      type: crudUtil.TABLE,
      join: crudUtil.LEFT,
      schema: self.schemaName,
      tableName: "permission",
      cond:
        [{
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "permission_id",
          operator: crudUtil.EQ,
          rightSide: "id"
        }]
    }],
    where:
    [{
      typeCond: crudUtil.SIMPLE_COND,
      leftSide: "role_id",
      operator: crudUtil.EQ,
      rightSide: "$1"
    }]
  };

  // Exec query
  self.crud.select(queryOpt,queryVal,function(err,res)
  {
    if (err)
      return callback(err);

    if (res.result)
    {
      obj.permission = [];

      for (var j = 0;j < res.result.length;j++)
        obj.permission.push(res.result[j].id);
    }

    callback(null);
  });
}

// manage permissions (add and remove), into permission_role entity,
// related to a given role
function managePermissionToRole(obj,callback)
{
  var crudUtil = self.crudUtils;
  var managePermRoleQueryOpt = {};
  var queryVal = [];

  queryVal.push({value:obj[0]});
  queryVal.push({value:obj[1]});

  if (obj[2] == "add")
  {
    managePermRoleQueryOpt =
    {
      queryName: "AddPermissionForRole",
      transName: obj[3],
      table: {schema:self.schemaName, name:"permission_role"},
      fields: [
        {name:"role_id"},
        {name:"permission_id"}
      ]
    };

    // Exec query
    self.crud.insert(managePermRoleQueryOpt,queryVal,function(err,res)
    {
      callback(err);
    });
  }
  else if (obj[2] == "del")
  {
    managePermRoleQueryOpt =
    {
      queryName: "DeletePermissionForRole",
      transName: obj[3],
      table: {schema:self.schemaName, name:"permission_role"},
      where: [
        {
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "role_id",
          operator: crudUtil.EQ,
          rightSide: "$1",
          nextCond: crudUtil.AND
        },
        {
          typeCond: crudUtil.SIMPLE_COND,
          leftSide: "permission_id",
          operator: crudUtil.EQ,
          rightSide: "$2"
        }
      ]
    };

    // Exec query
    self.crud.delete(managePermRoleQueryOpt,queryVal,function(err,res)
    {
      callback(err);
    });
  }
  else
  {
    // TODO: manage this error? Is impossible reach this else....
  }
}

// perform the logic delete of the given role
function logicDeleteRole(params, callback)
{
  var transactionName = "LogicDeleteRole_" + new Date().getTime();

  // begin transaction
  self.crud.beginTransaction(transactionName,function(bgErr)
  {
    if (bgErr)
    {
      callback(bgErr,null);
      return;
    }

    // remove permission related to role
    var queryOpt =
    {
      queryName: "DeleteAllPermissionsForRole",
      table: {schema:self.schemaName, name:"permission_role"},
      where: [{
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "role_id",
        operator: self.crudUtils.EQ,
        rightSide: "$1"
      }],
      returning:[{name:"permission_id"}]
    };

    var queryVal = [{value:params.id}];

    // Exec delete permission query
    self.crud.delete(queryOpt,queryVal,function(errPerm,resPerm)
    {
      if (errPerm)
      {
        // error on delete permissions -> exec rollback
        self.crud.rollbackTransaction(transactionName,function(rollErr)
        {
          callback(errPerm,null);
        });
      }
      else
      {
        // success on delete permissions -> logic delete role
        params.transName = transactionName;

        role.super_.prototype.logicDelete.call(self,params,
        function(errRole,resRole)
        {
          if (errRole)
          {
            // error on logic delete role -> exec rollback
            self.crud.rollbackTransaction(transactionName,function(rollErr)
            {
              callback(errRole,null);
            });
          }
          else
          {
            // success on logic delete role -> exec commit
            self.crud.commitTransaction(transactionName,function(comErr)
            {
              if (comErr)
                callback(comErr,null);
              else
                callback(errRole,resRole);
            });
          }
        });
      }
    });
  });
}

// perform the  delete of the given role
function deleteRole(params,callback)
{
  var transactionName = "DeleteRole_" + new Date().getTime();

  // begin transaction
  self.crud.beginTransaction(transactionName,function(bgErr)
  {
    if (bgErr)
    {
      callback(bgErr,null);
      return;
    }

    // remove permission related to role
    var queryOpt =
    {
      queryName: "DeleteAllPermissionsForRole",
      transName: transactionName,
      table: {schema:self.schemaName, name:"permission_role"},
      where: [
        {
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "role_id",
          operator: self.crudUtils.EQ,
          rightSide: "$1"
        }
      ],
      returning:[{name:"permission_id"}]
    };

    var queryVal = [{value:params.id}];

    // Exec delete permission query
    self.crud.delete(queryOpt,queryVal,function(errPerm,resPerm)
    {
      // error on delete permissions -> exec rollback
      if (errPerm)
      {
        self.crud.rollbackTransaction(transactionName,function(rollErr)
        {
          callback(errPerm,null);
        });
      }
      else
      {
        // success on delete permissions -> delete role
        params.transName = transactionName;

        role.super_.prototype.delete.call(self,params,function(errRole,resRole)
        {
          if (errRole)
          {
            // error on delete role -> exec rollback
            self.crud.rollbackTransaction(transactionName,function(rollErr)
            {
              callback(errRole,null);
            });
          }
          else
          {
            // success on delete role -> exec commit
            self.crud.commitTransaction(transactionName,function(comErr)
            {
              if (comErr)
                callback(comErr,null);
              else
                callback(errRole,resRole);
            });
          }
        });
      }
    });
  });
}
