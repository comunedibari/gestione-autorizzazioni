/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entTemp = require("../../lib/entityTemplate").entityTemplate;
var async = require("async");
var util = require("util");
var fs = require("fs");

var self = {};

var wgLayer = function(schema)
{
  wgLayer.super_.call(this);

  this.moduleName = "Entity wgLayer";
  this.entityName = "wgLayer";
  this.tableName = "wg_layer";
  this.schemaName = schema;
  this.attachTableName = "wg_layer_attach";
  this.attachSchemaName = schema;

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;

  this.retFieldObj = [{name:"id"},{name:"label"},{name:"permission"}];
}

/*
 * Inheritance.
 */
util.inherits(wgLayer,entTemp);

wgLayer.prototype.init = function(opt)
{
  self = this;
  wgLayer.super_.prototype.init.call(self,opt);
}

wgLayer.prototype.master = function(opt,callback)
{
  var aPerm = opt.object ? opt.object.permLayers : null;

  if (aPerm && aPerm.length)
  {
    /*
     * Get layers for given permission and without permission.
     */
    var aPar = [];
    var qVal = [];

    for (var i = 0;i < aPerm.length;i++)
    {
      aPar.push("$" + (i+1));
      qVal.push({value: aPerm[i]});
    }

    var qOpt = {
      queryName: "wgLayerForPerm",
      fields: self.crudUtils.ALL_FIELDS,
      from: [{
        schema: self.schemaName,
        name: "view_wg_layer",
        type: self.crudUtils.TABLE
      }],
      where: [
        {
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "permission",
          operator: self.crudUtils.IN,
          rightSide: aPar.join(),
          nextCond: self.crudUtils.OR
        },
        {
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "permission",
          operator: self.crudUtils.IS,
          rightSide: self.crudUtils.NULL
        }
      ],
      //TODO: get ord from opt
      ordering: [
        {field:"id_category", orderType:self.crudUtils.ASC},
        {field:"depth", orderType:self.crudUtils.ASC},
        {field:"_position", orderType:self.crudUtils.ASC}
      ]
    };

    self.crud.select(qOpt,qVal,callback);
  }
  else
  {
    /*
     * Get layers without permission.
     */
    var qOpt = {
      fields: self.crudUtils.ALL_FIELDS,
      from: [{
        schema: self.schemaName,
        name: "view_wg_layer",
        type: self.crudUtils.TABLE
      }],
      where: [{
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "permission",
        operator: self.crudUtils.IS,
        rightSide: self.crudUtils.NULL
      }],
      ordering: [
        {field:"id_category", orderType:self.crudUtils.ASC},
        {field:"depth", orderType:self.crudUtils.ASC},
        {field:"_position", orderType:self.crudUtils.ASC}
      ]
    };

    self.crud.select(qOpt,[],callback);
  }
}

wgLayer.prototype.insert = function(opt,callback)
{
  var transOpt = {fake:true, name:opt.transName};
  var aLayer = [opt.object];
  var aToIns = [];

  // Check transaction
  if (!opt.transName)
  {
    opt.transName = "InsertLayer_" + new Date().getTime();
    transOpt.fake = false;
    transOpt.name = opt.transName;
  }

  // Get all children layers
  getChildrenLayer(opt.object.layers,aLayer);

  // Begin transaction
  beginTransaction(transOpt,function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // Insert
    for (var i = 0, len = aLayer.length;i < len;i++)
    {
      aToIns.push({
        sysuser_id: opt.sysuser_id,
        transName: opt.transName,
        sio_id: opt.sio_id,
        object: aLayer[i]
      });

      delete aLayer[i].layers;
    }

    async.eachLimit(aToIns,1,insert,function(insErr)
    {
      if (insErr)
      {
        // Rollback transaction
        rollbackTransaction(transOpt);
        callback(insErr,null);
      }
      else
      {
        // Commit transaction
        commitTransaction(transOpt,function(ctErr)
        {
          callback(ctErr,ctErr ? null : {result:{}});
        });
      }
    });
  });
}

wgLayer.prototype.update = function(opt,callback)
{
  var transOpt = {fake:true, name:opt.transName};
  var aLayer = [opt.object];
  var aToIns = [];
  var aToUpd = [];

  // Configure parent layer
  opt.object.id = opt.id;
  opt.object.op = "U";

  // Check transaction
  if (!opt.transName)
  {
    opt.transName = "UpdateLayer_" + new Date().getTime();
    transOpt.fake = false;
    transOpt.name = opt.transName;
  }

  // Get all children layers
  getChildrenLayer(opt.object.layers,aLayer);

  // Begin transaction
  beginTransaction(transOpt,function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // Look for insert or update layers
    for (var i = 0, len = aLayer.length;i < len;i++)
    {
      var obj = {
        sysuser_id: opt.sysuser_id,
        transName: opt.transName,
        sio_id: opt.sio_id,
        object: aLayer[i]
      };

      switch (aLayer[i].op)
      {
        case "I":
          aToIns.push(obj);
          break;
        case "U":
          obj.id = aLayer[i].id;
          delete aLayer[i].id;

          aToUpd.push(obj);
          break;
      }

      delete aLayer[i].layers;
      delete aLayer[i].op;
    }

    // Update
    async.eachLimit(aToUpd,1,update,function(updErr)
    {
      if (updErr)
      {
        rollbackTransaction(transOpt);
        callback(updErr,null);
        return;
      }

      // Insert
      async.eachLimit(aToIns,1,insert,function(insErr)
      {
        if (insErr)
        {
          rollbackTransaction(transOpt);
          callback(insErr,null);
        }
        else
        {
          // Commit transaction
          commitTransaction(transOpt,function(ctErr)
          {
            callback(ctErr,ctErr ? null : {result:{}});
          });
        }
      });
    });
  });
}

wgLayer.prototype.delete = function(opt,callback)
{
  var transOpt = {fake:true, name:opt.transName};
  var aLayId = [opt.id];
  var aToDel = [];

  // Check transaction
  if (!opt.transName)
  {
    opt.transName = "DeleteLayer_" + new Date().getTime();
    transOpt.fake = false;
    transOpt.name = opt.transName;
  }

  // Begin transaction
  beginTransaction(transOpt,function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    /* Get all children layers:
    WITH RECURSIVE children AS
    (
      SELECT id FROM wg_layer WHERE id_parent = $1
      UNION
      SELECT l.id FROM wg_layer AS l JOIN children ON l.id_parent = children.id
    )
    SELECT id FROM children
    */
    var qVal = [{value: opt.id}];
    var qOpt = {
      with: {
        type: self.crudUtils.RECURSIVE,
        subQueryName: "children",
        as: {
          fields: [{name:"id"}],
          from: [{
            schema: self.schemaName,
            name: self.tableName,
            type: self.crudUtils.TABLE
          }],
          where: [{
            typeCond: self.crudUtils.SIMPLE_COND,
            leftSide: "id_parent",
            operator: self.crudUtils.EQ,
            rightSide: "$1"
          }],
          union:[{
            fields: [{name:"id", aliasT:"l"}],
            from: [{
              schema: self.schemaName,
              name: self.tableName,
              type: self.crudUtils.TABLE,
              alias: "l"
            }],
            join:[{
              type: self.crudUtils.TABLE,
              join: self.crudUtils.JOIN,
              tableName: "children",
              cond:[{
                typeCond: self.crudUtils.SIMPLE_COND,
                leftSide: "id_parent",
                leftAlias: "l",
                operator: self.crudUtils.EQ,
                rightSide: "id",
                rightAlias:"children"
              }]
            }]
          }]
        }
      },
      fields:[{name:"id"}],
      from:[{name:"children", type:self.crudUtils.TABLE}]
    };

    self.crud.select(qOpt,qVal,function(chErr,chRes)
    {
      if (chErr)
      {
        rollbackTransaction(transOpt);
        callback(chErr,null);
        return;
      }

      // Process children layers response
      for (var i = 0, len = chRes.result.length;i < len;i++)
        aLayId.push(chRes.result[i].id);

      for (var i = aLayId.length-1;i >= 0;i--)
        aToDel.push({
          sysuser_id: opt.sysuser_id,
          transName: opt.transName,
          simple: opt.object.simple,
          sio_id: opt.sio_id,
          id: aLayId[i]
        });

      async.eachLimit(aToDel,1,delete_,function(delErr)
      {
        if (delErr)
        {
          rollbackTransaction(transOpt);
          callback(delErr,null);
        }
        else
        {
          // Commit transaction
          commitTransaction(transOpt,function(ctErr)
          {
            callback(ctErr,ctErr ? null : {result:{}});
          });
        }
      });
    });
  });
}

/*
 * New method.
 */
wgLayer.prototype.getConfig = function(opt,callback)
{
  /* Load master */
  var masOpt = {
    sysuser_id: opt.sysuser_id,
    object: {
      permLayers: opt.object.permLayers,
      ord: "id_category|ASC;depth|ASC;_position|ASC"
    }
  };

  self.master(masOpt,function(err,res)
  {
    if (err)
    {
      callback(err,null);
      return;
    }

    /* Get legend config */
    var legEnt = self.entityHolder.getEntity("wgLegend");
    if (!legEnt)
    {
      callback({message:"Cannot retrieve wgLegend entity"},null);
      return;
    }

    legEnt.getConfig(opt,function(legErr,legRes)
    {
      // Ignore error
      if (!legRes)
        legRes = {};

      /* Prepare response */
      var aRes = res.result;
      var retObj = {};
      var parentObj = {};

      for (var i = 0,len = aRes.length;i < len;i++)
      {
        var curLay = aRes[i],
          idCat = curLay.id_category,
          idPar = curLay.id_parent;

        // Add legend to layer
        if (legRes[curLay.id])
          curLay.legend = legRes[curLay.id];

        // Add category to retObj
        if (!retObj[idCat])
          retObj[idCat] = [];

        // Add layer to category or to parent layer
        if (!idPar)
        {
          retObj[idCat].push(curLay);
        }
        else
        {
          // Parent layer does not exist if it has a permission that
          // is not sent in the request
          if (parentObj[idCat+"_"+idPar])
          {
            if (!parentObj[idCat+"_"+idPar].layers)
              parentObj[idCat+"_"+idPar].layers = [];

            parentObj[idCat+"_"+idPar].layers.push(curLay);
          }
        }

        // Update parent object
        parentObj[idCat+"_"+curLay.id] = curLay;
      }

      /* Send response */
      callback(null,retObj);
    });
  });
}

wgLayer.prototype.bulkUpdate = function(opt,callback)
{
  // NOTE: with this method cannot update i18n entry
  var transName = "BulkUpdateLayer_" + new Date().getTime();
  var aObject = [];

  for (var i = 0;i < opt.object.length;i++)
  {
    aObject.push({
      sysuser_id: opt.sysuser_id,
      transName: transName,
      object: opt.object[i],
      id: opt.object[i].id
    });

    delete opt.object[i].id;
  }

  // Begin transaction
  self.crud.beginTransaction(transName,function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    // Update
    async.each(aObject,function(obj,cb)
    {
      wgLayer.super_.prototype.update.call(self,obj,function(err,res)
      {
        cb(err);
      });
    },
    function(err)
    {
      if (err)
      {
        self.crud.rollbackTransaction(transName,function(rtErr){});
        callback(err,null);
        return;
      }

      // Commit transaction
      self.crud.commitTransaction(transName,function(ctErr)
      {
        callback(ctErr,ctErr ? null : {result: {}});
      });
    });
  });
}

wgLayer.prototype.delAttachByName = function(opt,callback)
{
  var name = opt.object.name;
  if (!name)
  {
    callback({message:"NULL attach name"},null);
    return;
  }

  // Get attach id
  var qVal = [{value: opt.id},{value: name}];
  var qOpt =
  {
    transName: opt.transName,
    fields: [{name:"id"}],
    from: [{
      schema: self.schemaName,
      name: self.attachTableName,
      type: self.crudUtils.TABLE
    }],
    where:
    [
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "entity_id",
        operator: self.crudUtils.EQ,
        rightSide: "$1",
        nextCond: self.crudUtils.AND
      },
      {
        typeCond: self.crudUtils.SIMPLE_COND,
        leftSide: "name",
        operator: self.crudUtils.EQ,
        rightSide: "$2"
      }
    ]
  };

  self.crud.select(qOpt,qVal,function(err,res)
  {
    if (err || !res || !res.result || !res.result.length)
    {
      callback(err,res);
      return;
    }

    // Delete attach
    var delOpt = {
      transName: opt.transName,
      attach_id: res.result[0].id,
      sysuser_id: opt.sysuser_id
    };

    self.deleteAttach(delOpt,callback);
  });
}

wgLayer.prototype.updatePrintImage = function(opt,callback)
{
  var path = self.attachment.path + "/" + self.entityName,
    pref = path + "/" + opt.id + "_";

  /* Check path */
  if (!fs.existsSync(path))
  {
    try
    {
      fs.mkdirSync(path);
    }
    catch (err)
    {
      callback(err,null);
      return;
    }
  }

  /* Save image */
  var aImage = [];

  for (var key in opt.object)
    aImage.push({
      name: key,
      data: opt.object[key].replace("data:image/png;base64,","")
    });

  async.each(aImage,function(obj,cb)
  {
    fs.writeFile(pref+obj.name,new Buffer(obj.data,"base64"),cb);
  },
  function(err)
  {
    callback(err,err ? null : {result:"ok"});
  });
}

/*
 * Exports.
 */
exports.wgLayer = wgLayer;

/*
 * Private utility method.
 */
function getChildrenLayer(aChildren,aOut)
{
  if (aChildren)
  {
    aOut.push.apply(aOut,aChildren);

    for (var i = 0, len = aChildren.length;i < len;i++)
      getChildrenLayer(aChildren[i].layers,aOut);
  }
}

function insert(opt,callback)
{
  // Look for i18n
  var i18nOpt = {
    sysuser_id: opt.sysuser_id,
    transName: opt.transName,
    method: "insert",
    object: opt.object.i18n
  };

  delete opt.object.i18n;

  // Look for legend
  var legOpt = {
    sysuser_id: opt.sysuser_id,
    transName: opt.transName,
    method: "insert",
    object: opt.object.legend
  };

  delete opt.object.legend;

  // Look for permission
  var permOpt = {
    sysuser_id: opt.sysuser_id,
    transName: opt.transName,
    object: opt.object.permission_obj
  };

  delete opt.object.permission_obj;

  // Insert layer
  wgLayer.super_.prototype.insert.call(self,opt,function(err,res)
  {
    if (err)
    {
      callback(err);
      return;
    }

    // Insert i18n entry
    manageI18N(i18nOpt,function(i18nErr)
    {
      if (i18nErr)
      {
        callback(i18nErr);
        return;
      }

      // Insert legend
      manageLegend(legOpt,function(legErr)
      {
        if (legErr)
        {
          callback(legErr);
          return;
        }

        // Manage permission
        managePermission(permOpt,function(permErr)
        {
          callback(permErr);
        });
      });
    });
  });
}

function update(opt,callback)
{
  // Look for i18n
  var i18nOpt = {
    sysuser_id: opt.sysuser_id,
    transName: opt.transName,
    method: "updateWoId",
    object: opt.object.i18n
  };

  delete opt.object.i18n;

  // Look for legend
  var legOpt = {
    sysuser_id: opt.sysuser_id,
    transName: opt.transName,
    method: "upsert",
    object: opt.object.legend
  };

  delete opt.object.legend;

  // Look for permission
  var permOpt = {
    sysuser_id: opt.sysuser_id,
    transName: opt.transName,
    object: opt.object.permission_obj
  };

  delete opt.object.permission_obj;

  // Update
  var aFunc = [
    function(cb) {wgLayer.super_.prototype.update.call(self,opt,cb);},
    function(cb) {manageI18N(i18nOpt,cb);},
    function(cb) {manageLegend(legOpt,cb);},
    function(cb) {managePermission(permOpt,cb);}
  ];

  async.parallelLimit(aFunc,1,function(err,res)
  {
    callback(err);
  });
}

function delete_(opt,callback)
{
  /*
   * Note: possible user style are automatically deleted
   *       by constraint (ON DELETE CASCADE)
   */

  // Get legend for given layer
  var qVal = [{value: opt.id}];
  var qOpt =
  {
    transName: opt.transName,
    fields: [{name:"id"}],
    from: [{
      schema: self.schemaName,
      name: "wg_legend",
      type: self.crudUtils.TABLE
    }],
    where: [{
      typeCond: self.crudUtils.SIMPLE_COND,
      leftSide: "id_layer",
      operator: self.crudUtils.EQ,
      rightSide: "$1"}]
  };

  self.crud.select(qOpt,qVal,function(legErr,legRes)
  {
    if (legErr)
    {
      callback(legErr);
      return;
    }

    // Delete legend
    var aLegOpt = [];

    for (var i = 0;i < legRes.result.length;i++)
      aLegOpt.push({
        sysuser_id: opt.sysuser_id,
        transName: opt.transName,
        method: "delete",
        object: {},
        id: legRes.result[i].id
      });

    async.each(aLegOpt,manageLegend,function(delLegErr)
    {
      if (delLegErr)
      {
        callback(delLegErr);
        return;
      }

      // Get layer attachs
      qOpt =
      {
        transName: opt.transName,
        fields: [{name:"id"}],
        from: [{
          schema: self.schemaName,
          name: self.attachTableName,
          type: self.crudUtils.TABLE
        }],
        where: [{
          typeCond: self.crudUtils.SIMPLE_COND,
          leftSide: "entity_id",
          operator: self.crudUtils.EQ,
          rightSide: "$1"}]
      };

      self.crud.select(qOpt,qVal,function(attErr,attRes)
      {
        if (attErr)
        {
          callback(attErr);
          return;
        }

        // Delete attachs
        var aAttOpt = [];

        for (var j = 0;j < attRes.result.length;j++)
          aAttOpt.push({
            sysuser_id: opt.sysuser_id,
            transName: opt.transName,
            attach_id: attRes.result[j].id
          });

        async.each(aAttOpt,deleteAttach,function(delAttErr)
        {
          if (delAttErr)
          {
            callback(delAttErr);
            return;
          }

          // Delete layer
          wgLayer.super_.prototype.delete.call(self,opt,function(err,res)
          {
            if (err)
            {
              callback(err);
              return;
            }

            // Delete i18n
            var i18nOpt = {
              sysuser_id: opt.sysuser_id,
              transName: opt.transName,
              method: "deleteWoId",
              object: opt.simple ? null : {label_key: res.result.label}
            };

            manageI18N(i18nOpt,function(i18nErr)
            {
              if (i18nErr || !res.result.permission)
              {
                callback(i18nErr);
                return;
              }

              // Delete permission
              var permOpt = {
                sysuser_id: opt.sysuser_id,
                transName: opt.transName,
                object: {
                  op: "D",
                  name: res.result.permission
                }
              };

              managePermission(permOpt,callback);
            });
          });

        });
      });
    });
  });
}

function manageI18N(opt,callback)
{
  if (!opt.object || !opt.object.label_key)
  {
    callback(null);
    return;
  }

  // Get entity and method
  var entity = self.entityHolder.getEntity("i18n");
  var method = opt.method;

  if (!entity)
  {
    callback({message:"Cannot retrieve i18n entity"});
    return;
  }

  // Exec
  entity[method](opt,function(err,res)
  {
    callback(err);
  });
}

function manageLegend(opt,callback)
{
  if (!opt.object)
  {
    callback(null);
    return;
  }

  // Get entity and method
  var entity = self.entityHolder.getEntity("wgLegend");
  var method = opt.method;

  if (!entity)
  {
    callback({message:"Cannot retrieve wgLegend entity"});
    return;
  }

  // Exec method
  entity[method](opt,function(err,res)
  {
    callback(err);
  });
}

function managePermission(opt,callback)
{
  if (!opt.object)
  {
    callback(null);
    return;
  }

  // Get entity and method
  var entity = self.entityHolder.getEntity("permission");
  var method = null;

  switch (opt.object.op)
  {
    case "I":
      opt.object.app_desc = "Layer gis";
      opt.object.app_name = "webgis";
      method = "insert";
      break;
    case "U": method = "updateByName"; break;
    case "D": method = "deleteByName"; break;
  }

  delete opt.object.op;

  if (!entity || !method)
  {
    callback({message:"Cannot retrieve permission entity/method"});
    return;
  }

  // Exec
  entity[method](opt,function(err,res)
  {
    callback(err);
  });
}

function deleteAttach(opt,callback)
{
  wgLayer.super_.prototype.deleteAttach.call(self,opt,function(err,res)
  {
    callback(err);
  });
}

function beginTransaction(opt,callback)
{
  if (opt.fake)
    callback(null);
  else
    self.crud.beginTransaction(opt.name,callback);
}

function commitTransaction(opt,callback)
{
  if (opt.fake)
    callback(null);
  else
    self.crud.commitTransaction(opt.name,callback);
}

function rollbackTransaction(opt)
{
  if (!opt.fake)
    self.crud.rollbackTransaction(opt.name,function(err){});
}
