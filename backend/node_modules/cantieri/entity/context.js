/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entTemp = require(process.cwd()+"/../lib/entityTemplate").entityTemplate;
var async = require("async");
var util = require("util");
var self = {};

/*
 * Context-Table array
 */
var aCtxTable = [
//   ["authority","authority"],
  ["roadsiteStatus","roadsite_status"],
  ["moveStatus","move_status"],
  ["userTitle","ctx_title"],
  ["authorityFunction","ctx_function"],
  ["signagePosition","move_signage_position"]
];

/*
 * Table-ContextUrl object
 */
var objTableCtxUrl = {};

/*
 * Context entity
 */
var context = function()
{
  context.super_.call(this);

  this.moduleName = "Entity context";
  this.entityName = "context";

  this.ctxObj = null;
}

/*
 * Inheritance
 */
util.inherits(context,entTemp);

context.prototype.init = function(options)
{
  self = this;
  context.super_.prototype.init.call(self,options);
}

context.prototype.master = function(params,callback)
{
  if (self.ctxObj)
  {
    callback(null,self.ctxObj);
    return;
  }

  // Build context
  var queryArray = [];
  self.ctxObj = {};

  for (var i = 0;i < aCtxTable.length;i++)
  {
    queryArray.push({
      qOpt:
      {
        queryName: aCtxTable[i][0],
        fields: self.crudUtils.ALL_FIELDS,
        from: [{name:aCtxTable[i][1], type:self.crudUtils.TABLE}],
        ordering: [{
          field: aCtxTable[i][2] || "name",
          orderType: self.crudUtils.ASC
        }]
      },
      qVal: []
    });
  }

  async.each(queryArray,loadTable,function(err)
  {
    callback(err,self.ctxObj);
  });
}

/*
 * New methods
 */
context.prototype.tableInfo = function(opt,callback)
{
  if (!opt.object.table)
  {
    callback({message: "Missing table parameter"});
    return;
  }

  /*
   * Get table info from db
   */
  var qOpt = {queryString: `SELECT
    c.column_name AS column,
    c.data_type AS type,
    kcu.constraint_name,
    tc.constraint_type,
    ccu.table_schema AS fk_schema,
    ccu.table_name AS fk_table,
    ccu.column_name AS fk_column
    FROM information_schema.columns c
    LEFT JOIN information_schema.key_column_usage kcu ON
      c.table_name = kcu.table_name AND c.column_name = kcu.column_name
    LEFT JOIN information_schema.table_constraints tc ON
      tc.constraint_name = kcu.constraint_name
    LEFT JOIN information_schema.constraint_column_usage ccu ON
      ccu.constraint_name = kcu.constraint_name
    WHERE c.table_name = $1`
  };

  self.crud.select(qOpt,[{value: opt.object.table}],function(err,res)
  {
    if (err)
    {
      callback(err,null);
      return;
    }

    /*
     * Process response
     */
    var aRet = [];

    for (var j = 0;j < res.result.length;j++)
    {
      var inObj = res.result[j];
      var outObj = {
        column: inObj.column,
        type: inObj.type,
        context: null,
        url: null,
        key: null
      };

      if (inObj.constraint_type == "FOREIGN KEY")
      {
        outObj.context = ctxNameForTable(inObj.fk_schema,inObj.fk_table);
        outObj.url = objTableCtxUrl[`${inObj.fk_schema}.${inObj.fk_table}`] || null;
        outObj.key = inObj.fk_column;
      }

      aRet.push(outObj);
    }

    callback(null,{result: aRet});
  });
}

/*
 * Exports
 */
exports.context = context;

/*
 * Private functions
 */
function loadTable(obj,callback)
{
  self.crud.select(obj.qOpt,obj.qVal,function(err,res)
  {
    if (!err && res && res.result)
      self.ctxObj[obj.qOpt.queryName] = res.result;

    callback(err);
  });
}

function ctxNameForTable(schema,table)
{
  if (schema && schema != "public")
    table = `${schema}.${table}`;

  for (var j = 0;j < aCtxTable.length;j++)
    if (aCtxTable[j][1] == table)
      return aCtxTable[j][0];

  return null;
}

