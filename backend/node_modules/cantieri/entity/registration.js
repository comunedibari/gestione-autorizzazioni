/*
 *    Date: 
 *  Author: 
 * Project: 
 *
 * 
 */

var entTemp = require(process.cwd()+"/../lib/entityTemplate").entityTemplate;
var util = require("util");
var self = {};
var async = require("async");

var mailer = require("nodemailer");
var _smtp = null;

var emConfig = require("config/emConf.json");


var registration = function()
{
  registration.super_.call(this);

  this.moduleName = "Entity registration";
  this.entityName = "registration";
  this.tableName = "registration";

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;
}

/*
 * Inheritance.
 */
util.inherits(registration,entTemp);

registration.prototype.init = function(opt)
{
  self = this;

  // create SMTP transport reading configuration
  _smtp = mailer.createTransport(emConfig.smtp);

  registration.super_.prototype.init.call(self,opt);
}

registration.prototype.count = function(opt,callback)
{
  opt.tableName = "view_registration";
  registration.super_.prototype.count.call(self,opt,callback);
}

registration.prototype.master = function(opt,callback)
{
  opt.tableName = "view_registration";
  registration.super_.prototype.master.call(self,opt,callback);
}

registration.prototype.insert = function(opt,callback)
{

  var body = opt.body;
  var user = null;
  var authority = null;
  var authorization = null;

  // save user/authority/authorization objects to use into separate insert
  try
  {
    if (body.user)
      user = JSON.parse(body.user);

    if (body.authority)
      authority = JSON.parse(body.authority);

    if (body.authorization)
      authorization = JSON.parse(body.authorization);
  }
  catch(e)
  {
    var errMsg = "Exception during object json parse!";
    self.log.error(self.moduleName + " - " + errMsg);
    callback({message:errMsg},null);
    return;
  }

  delete body.user;
  delete body.authority;
  delete body.authorization;

  var reg = null;

  // check for attachments
  var fileAuth = opt.files ? opt.files[0] : null;

  var transName = "InsertRegistration_" + new Date().getTime();

  /*
   * Begin transaction
   */
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

      // Insert authority
    var authorityEntity = self.entityHolder.getEntity("authority");

    if (!authorityEntity)
      return callback(null, null);

    var authOpt = {
      transName: transName,
      object: authority
    };

    getAuthorityOtherwiseAdd(authOpt, authorityEntity, function(errAuthority,resAuthority)
    {
      if (errAuthority || !resAuthority)
      {
        self.log.error(self.moduleName + " - Error on get authority for registration");
        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(errAuthority,null);
          return;
        });
      }

      // Retrieve authority id
      var authId = resAuthority.result.id;

      // Insert user and authorization in tasks
      var tasks = {};

      var userEntity = self.entityHolder.getEntity("user");

      if (!userEntity)
      {
        self.crud.rollbackTransaction(transName,function(e)
        {
          callback(null, null);
          return;
        });
      }

      // Add authority to user
      user.authority_id = authId;

      var userOpt = {
        object: user,
        transName: transName
      };

      tasks.user = function(cb) {userEntity.insert(userOpt, cb);};

      if (authorization)
      {
        var authorizationEntity = self.entityHolder.getEntity("authorization");

        if (!authorizationEntity)
        {
          self.crud.rollbackTransaction(transName,function(e)
          {
            callback(null, null);
            return;
          });
        }

        // Add authority to authorization
        authorization.authority_id = authId;
        authorization.name = resAuthority.result.name;
        authorization.enabled = resAuthority.result.enabled;

        var authorizationOpt = {
          object: authorization,
          transName: transName,
          files: [fileAuth]
        };

        tasks.authorization = function(cb) {
          authorizationEntity.insert(authorizationOpt, cb);
        };
      }

      // Execute tasks
      async.parallelLimit(tasks,1,function(tErr, tRes)
      {
        if (tErr)
        {
          // manage tasks error
          self.log.error(self.moduleName + " - Error: " + tErr.message);

          self.crud.rollbackTransaction(transName,function(e)
          {
            callback(tErr,null);
            return;
          });
        }
        else
        {
          // Insert registration
          reg = {};
          reg.user_id = tRes.user.result.id;
          reg.authority_id = authId;

          regOpt =
          {
            object: reg,
            transName: transName,
            sysuser_id: opt.sysuser_id
          }

          registration.super_.prototype.insert.call(self, regOpt, function(errI,resI)
          {
            if (errI)
            {
              self.log.error(self.moduleName + " - Error on insert registration: " + errI.message);

              self.crud.rollbackTransaction(transName,function(e)
              {
                callback(errI,null);
                return;
              });
            }
            else
            {
              self.crud.commitTransaction(transName, function(e)
              {
                callback(errI,errI ? null : resI);
              });


              if (authority.function_id == 1) //Manutenzione strade
              {
                var subject = "Richiesta autorizzazione azienda";
                var textMail = "L'azienda " + authority.name + " ha inviato la richiesta di iscrizione " +
                "alla piattaforma di gestione manutenzione strade del comune di Bari. " +
                "Si prega di validare la suddetta richiesta.";
                var recipients = emConfig.smtp.roadsite.admin;

                var mailOpt =
                {
                  from: emConfig.smtp.from,
                  to: recipients,
                  subject: subject,
                  text: textMail
                };

                self.log.info(self.moduleName+" - Sending mail to change authorization ");

                _smtp.sendMail(mailOpt,function(mErr,mRes)
                {
                  if (mErr)
                  {
                    self.log.error(self.moduleName+" - Cannot send mail to change authorization "+mErr.message);
                    return;
                  }
                });
              }
            }
          });
        }
      });
    });
  });

}

/*
 * Export.
 */
exports.registration = registration;

/*
 * New methods
 */
registration.prototype.wholeDetail = function(opt,callback)
{
  // Insert user and authorization in tasks
  var tasks = {};

  var userEntity = self.entityHolder.getEntity("user");

  if (!userEntity)
    return callback(null, null);

  var userOpt = {
    id: opt.object.user_id,
    sysuser_id: opt.sysuser_id
  };

  tasks.user = function(cb) {userEntity.detail(userOpt, cb);};

  var authorityEntity = self.entityHolder.getEntity("authority");

  if (!authorityEntity)
    return callback(null, null);

  var authOpt = {
    id: opt.object.authority_id,
    sysuser_id: opt.sysuser_id
  };

  tasks.authority = function(cb) {authorityEntity.detail(authOpt, cb);};

  // Execute tasks
  async.parallelLimit(tasks,1,function(tErr, tRes)
  {
    if (tErr)
    {
      // manage tasks error
      self.log.error(self.moduleName + " - Error: " + tErr.message);
      callback(tErr,null);
      return;
    }

    var retVal = {};
    retVal.user = tRes.user.result;
    retVal.authority = tRes.authority.result;
    if (tRes.authority.result && tRes.authority.result.authorization)
      retVal.authorization = tRes.authority.result.authorization;

    callback(tErr,tErr ? null : retVal);
  });
}

/*
 * Private function
 */

function getAuthorityOtherwiseAdd(opt,authEntity, callback)
{
    // Check if the authority is already present in the db
  var query = "SELECT  *  FROM public.authority WHERE (vat = $1) ";

  var qVal = [{value: opt.object.vat}];

  self.crud.select({queryString: query},qVal,function(aErr,aRes)
  {
    if (aRes && aRes.result && aRes.result.length == 0)
    {
      authEntity.insert(opt,function(errAI,resAI)
      {
        if (errAI || !resAI)
        {
          self.log.error(self.moduleName + " - Error on insert authority for registration");
          callback(errAI,null);
          return;
        }

        callback(errAI,resAI);
      });
    }
    else
    {
      callback(aErr, {result: aRes.result[0]});
    }

  });
}