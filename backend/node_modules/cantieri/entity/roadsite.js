/*
 *    Date: 2022 05 11
 *  Author: Catiana Trisolini
 * Project: Nodas - EntityManager
 *
 * Copyright 2022 SIT srl
 */

var entTemp = require(process.cwd()+"/../lib/entityTemplate").entityTemplate;
var util = require("util");
var async = require("async");
var fs = require("fs");
var mailer = require("nodemailer");
var iconv = require("iconv-lite");
var self = {};
var _smtp = null;
var _smtpPec = null;

var config = require("config/protocol.json");
var emConfig = require("config/emConf.json");

var STATUS_APPROVE = 3;
var STATUS_REJECT = 4;

var roadsite = function()
{
  roadsite.super_.call(this);

  this.moduleName = "Entity roadsite";
  this.entityName = "roadsite";
  this.tableName = "roadsite";
  this.tableSrid = 32633;

  this.fieldTypeObj = {
    request_date: this.crudUtils.TIMESTAMP,
    protocol_request_date: this.crudUtils.TIMESTAMP,
    protocol_approved_date: this.crudUtils.TIMESTAMP,
    start_date: this.crudUtils.TIMESTAMP,
    end_date: this.crudUtils.TIMESTAMP
  };

  this.retFieldObj = [
    {name: "id"},
    {name: "town"},
    {name: "start_date"},
    {name: "address"},
  ];

  this.entityId = "id";
  this.entityIdType = this.crudUtils.INTEGER;
}

/*
 * Inheritance.
 */
util.inherits(roadsite,entTemp);

roadsite.prototype.init = function(opt)
{
  self = this;

  // workaround to resolve UNABLE_TO_VERIFY_LEAF_SIGNATURE bug
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

  // create SMTP transport reading configuration
  _smtp = mailer.createTransport(emConfig.smtp);

  // create SMTP pec transport reading configuration
  _smtpPec = mailer.createTransport(emConfig.smtpPec);

  roadsite.super_.prototype.init.call(self,opt);
}

roadsite.prototype.count = function(opt,callback)
{
  opt.tableName = "view_roadsite";

  roadsite.super_.prototype.count.call(self, opt, callback);
}

roadsite.prototype.master = function(opt,callback)
{
  // configure query object to return bounding box of geom
  // (geom can be point, line or polygon)
  var qOpt = {
    fields: [
      {name:"id"},
      {name:"authority_id"},
      {name:"open_user_id"},
      {name:"authority"},
      {name:"open_user"},
      {name:"request_date"},
      {name:"start_date"},
      {name:"end_date"},
      {name:"status_id"},
      {name:"address"},
      {name:"town"},
      {name:"protocol_request_date"},
      {name:"protocol_request_number"},
      {name:"protocol_approved_number"},
      {name:"protocol_approved_date"},
      {name:"geom"},
      {name:"ST_Xmin(ST_Buffer(geom,10))", aliasF:"x_min"},
      {name:"ST_Ymin(ST_Buffer(geom,10))", aliasF:"y_min"},
      {name:"ST_Xmax(ST_Buffer(geom,10))", aliasF:"x_max"},
      {name:"ST_Ymax(ST_Buffer(geom,10))", aliasF:"y_max"},
      {name: "ST_AsGeoJSON(geom)::json", aliasF:"geojson"}
    ],
    fieldType: {
      request_date: self.crudUtils.TIMESTAMP,
      protocol_request_date: self.crudUtils.TIMESTAMP,
      protocol_approved_date: self.crudUtils.TIMESTAMP,
      start_date: self.crudUtils.TIMESTAMP,
      end_date: self.crudUtils.TIMESTAMP
    },
    from: [{name:"view_roadsite", type:self.crudUtils.TABLE}]
  };

  opt.queryOpt = qOpt;
  opt.queryVal = [];

  roadsite.super_.prototype.master.call(self, opt, function(err,res)
  {
    if (res && res.result && res.result.length)
    {
      for (var idx=0; idx<res.result.length; idx++)
      {
        if (res.result[idx].geojson)
        {
          res.result[idx].geojson = {
            type: 'FeatureCollection',
            crs: {type: 'name', properties:{name:'EPSG:'+self.tableSrid}},
            features:[
              {
                type: 'Feature',
                geometry: res.result[idx].geojson,
                id: res.result[idx].id
              }
            ]
          };
        }
      }
    }

    callback(err,res);
  });
}

roadsite.prototype.detail = function(opt,callback)
{
  opt.tableName = "view_roadsite";

  roadsite.super_.prototype.detail.call(self, opt, callback);
}

roadsite.prototype.insert = function(opt,callback)
{
  var body = opt.body;

  // check for attachments
  var files = opt.files ? opt.files : null;

  var rsGeom  = null;
  var transName = "InsertRoadsite_" + new Date().getTime();

  /*
   * Begin transaction
   */
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    if (!body.geoJson && !body.srid)
    {
      var insOpt = {
        object: body,
        transName: transName,
        sysuser_id: opt.sysuser_id
      };

      roadsite.super_.prototype.insert.call(self, insOpt, function(err,res)
      {
        if (files && files.length)
        {
          var tasks = {};
          for (var idx = 0; idx < files.length; idx++)
          {
            var optUpload = {
              entity_id: res.result.id,
              sysuser_id: opt.sysuser_id,
              transName: transName,
              files: [files[idx]]
            };
            var typeAttach = files[idx].fieldname.substring(0, files[idx].fieldname.length);

            createUploadAttachTask(typeAttach, optUpload, tasks);
          }

          // Execute tasks
          async.parallelLimit(tasks,1,function(errT,resT)
          {
            if (errT)
            {
              // manage tasks error
              self.log.error(self.moduleName + " - Error: " + errT.message);

              self.crud.rollbackTransaction(transName,function(e)
              {
                callback(errT,null);
                return;
              });
            }
            else
            {
              self.crud.commitTransaction(transName, function(e)
              {
                callback(e,e ? null : res);
              });
            }
          });

        }
        else
        {
          self.crud.commitTransaction(transName, function(e)
          {
            callback(e,e ? null : res);
          });
        }

      });
    }
    else
    {
      var geoJson = body.geoJson;
      var srid    = body.srid;

      if (!geoJson || !srid)
      {
        var errMsg = "Missing parameters";

        self.log.error(self.moduleName + " - Save geoJson error: " + errMsg);
        self.crud.rollbackTransaction(transName,function(e)
        {
          callback({message: 1},null);
          return;
        });
      }

      //var geom = JSON.stringify(geoJson);
      geom  = geoJson;

      rsGeom = "ST_Transform(ST_SetSRID(ST_GeomFromGeoJSON('" + geom + "')," + srid + ")," + self.tableSrid + ") ";

      // remove geoJson and srid from input object before build and execute insert
      delete body.geoJson;
      delete body.srid;

      // build insert query
      var strListAttrs  = "";
      var strListValues = "";

      var index = 1;
      var qVal = [];

      // cycle on attributes to build dinamically attrs and values list
      Object.keys(body).forEach(function(key)
      {
        strListAttrs += key + ", ";

        strListValues += "$" + index + ", ";

        var valueObj = {value:body[key]};

        if (key == 'request_date')
          valueObj.type = self.crudUtils.TIMESTAMP;

        if (key == 'start_date')
        valueObj.type = self.crudUtils.TIMESTAMP;

        if (key == 'end_date')
        valueObj.type = self.crudUtils.TIMESTAMP;

        // if (key == 'protocol_request_date')
        //   valueObj.type = self.crudUtils.TIMESTAMP;

        // if (key == 'protocol_approved_date')
        //   valueObj.type = self.crudUtils.TIMESTAMP;

        qVal.push(valueObj);

        index++;
      });

      strListAttrs  += "geom";
      strListValues += rsGeom;

      // build insert query
      var qString =
        "INSERT INTO " + self.tableName + " (" + strListAttrs + ") " +
        "VALUES (" + strListValues + ") " +
        "RETURNING " + self.entityId + "," +
        "round(st_xmin(st_envelope(geom))::numeric,2)::float AS x_min," +
        "round(st_ymin(st_envelope(geom))::numeric,2)::float AS y_min," +
        "round(st_xmax(st_envelope(geom))::numeric,2)::float AS x_max," +
        "round(st_ymax(st_envelope(geom))::numeric,2)::float AS y_max;";

      // execute insert
      self.crud.insert({queryString: qString}, qVal, function(err,res)
      {
        if (err)
        {
          self.log.error(self.moduleName + " - Error on roadsite item: " + err.message);

          self.crud.rollbackTransaction(transName,function(e)
          {
            callback(err,null);
            return;
          });
        }
        else
        {
          if (files && files.length)
          {
            var tasks = {};
            for (var idx = 0; idx < files.length; idx++)
            {
              var optUpload = {
                entity_id: res.result.id,
                sysuser_id: opt.sysuser_id,
                transName: transName,
                files: [files[idx]]
              };
              var typeAttach = files[idx].fieldname.substring(0, files[idx].fieldname.length);

              createUploadAttachTask(typeAttach, optUpload, tasks);
            }

            // Execute tasks
            async.parallelLimit(tasks,1,function(errT,resT)
            {
              if (errT)
              {
                // manage tasks error
                self.log.error(self.moduleName + " - Error: " + errT.message);

                self.crud.rollbackTransaction(transName,function(e)
                {
                  callback(errT,null);
                  return;
                });
              }
              else
              {
                self.crud.commitTransaction(transName, function(e)
                {
                  callback(e,e ? null : res);
                });
              }
            });

          }
          else
          {
            self.crud.commitTransaction(transName, function(e)
            {
              callback(e,e ? null : res);
            });

          }
        }
      });
    }
  });
}

roadsite.prototype.delete = function(opt,callback)
{
  // Delete roadsite
  roadsite.super_.prototype.delete.call(self,opt,function(errD,resD)
  {
    if (errD)
    {
      self.log.error(self.moduleName + " - Error on remove roadsite function: "+ errD.message);

      callback(errD,null);
    }
    else
    {
      // remove files from filesystem if exist
      var files= [];
      fs.readdir(self.attachment.path+"/"+self.entityName, function(err,list)
      {
        if (list)
        {
          for(var i=0; i<list.length; i++)
          {
            if(list[i].indexOf(resD.result.id+"") >=0)
            {
              files.push(list[i]); //store the file name into the array files
            }
          }

          if (files && files.length)
          {

            var dir = self.attachment.path+"/"+self.entityName;

            files.forEach(function(item)
            {
              fs.unlink(dir+"/"+item,function(unlErr)
              {
                if (unlErr)
                  self.log.error(self.moduleName +
                    " - Error on delete file " + self.entityName + "/" +
                    item + ": " + unlErr.message);
                else
                  self.log.info(self.moduleName +
                    " - Deleted file "+self.entityName+"/"+item);
              });
            });

          }
        }

        callback(errD,resD);
      });
    }
  });
}

/*
 * Export.
 */
exports.roadsite = roadsite;

/*
 * New methods
 */

// Send request
roadsite.prototype.sendRequest = function(opt,callback)
{

  var body = opt.body;

  var docsToSend = [];

  // Read file to send
  // save docsToSend objects to use into separate insert
  try
  {
    if (body.docsToSend)
    {
      docsToSend = JSON.parse(body.docsToSend);
      delete body.docsToSend;
    }
  }
  catch(e)
  {
    var errMsg = "Exception during object json parse!";
    self.log.error(self.moduleName + " - " + errMsg);
    callback({message:errMsg},null);
    return;
  }

  var authority = body.authority;
  delete body.authority;

  var piva = body.piva;
  delete body.piva;

  var emailAuth = body.emailAuth;
  delete body.emailAuth;

  opt.id = body.id;

  var status_id = body.status_id;
  delete body.status_id;

  var town = body.town;
  delete body.town;

  var address = body.address;
  delete body.address;

  var dictFile =  {authorization:{}, project: {}, coor_communication: {}};

  self.updateAndUpload(opt, function(errUU,resUU)
  {
    if (errUU)
    {
      self.log.error(self.moduleName + " - Error on send request: "+ errUU.message);

      callback(errUU,null);
      return;
    }

    // Retrieve file authorization
    var dir = self.attachment.path + "/" + self.entityName;
    dictFile.authorization.fileName = opt.id + "_" + docsToSend[0];
    dictFile.authorization.fileToSend = dir + "/" + dictFile.authorization.fileName;
    // Encode file authorization in base64
    dictFile.authorization.stringBase64 = base64_encode(dictFile.authorization.fileToSend);

    // Retrieve file project
    dictFile.project.fileName = opt.id + "_" + docsToSend[1];
    dictFile.project.fileToSend = dir + "/" + dictFile.project.fileName;
    // Encode file project in base64
    dictFile.project.stringBase64 = base64_encode(dictFile.project.fileToSend);

    // Send Request
    var reqOpt = {
      host: config.entrata.url, // In protocol.json is setted host
      port: 80,
      path: config.entrata.path,
      headers: {"content-type": "application/json"}
    };

    var reqBody =
    {
      "protocolloRequest":
      {
        "mittente":
        {
          "personaGiuridica":
          {
            "ragioneSociale":authority,
            "partitaIVA":piva
          }
        },
        "documento":
        {
          "nomeFile": docsToSend[0],
          "contenuto":dictFile.authorization.stringBase64
        },
        "allegati":[
          {
            "documento":
            {
              "nomeFile": docsToSend[1],
              "contenuto":dictFile.project.stringBase64
            }
          }
        ],
        "areaOrganizzativaOmogenea":config.entrata.areaOrganizzativaOmogenea,
        "amministrazione":config.entrata.amministrazione,
        "oggetto":"Richiesta autorizzazione manomissione suolo pubblico per cantiere " +
        authority + " in " + address + " " + town,
        "idUtente":config.entrata.idUtente
      }
    };

    // Check presence of coord communication file
    if (docsToSend.length > 2)
    {
      // Retrieve file coord communication
      dictFile.coor_communication.fileName = opt.id + "_" + docsToSend[2];
      dictFile.coor_communication.fileToSend = dir + "/" + dictFile.coor_communication.fileName;
      // Encode file coord communication in base64
      dictFile.coor_communication.stringBase64 = base64_encode(dictFile.coor_communication.fileToSend);
      var jsonAttachCoorComm = {
        "documento":
        {
          "nomeFile": docsToSend[2],
          "contenuto":dictFile.coor_communication.stringBase64
        }
      }
      reqBody.protocolloRequest.allegati.push(jsonAttachCoorComm);
    }

    //self.log.error(JSON.stringify(reqBody));

    self.httpClient.post(reqOpt,JSON.stringify(reqBody),function(resE)
    {
      if (!resE)
      {
        var errMsg = "Cannot retrieve data";
        callback({message:errMsg},null);
        return;
      }

      /* Parse response */
      var result = null;
      try
      {
        result = JSON.parse(iconv.decode(new Buffer(resE),"utf-8"));
      }
      catch(e)
      {
        var errMsg = "Cannot parse data";
        callback({message:errMsg},null);
        return;
      }

      // Save status, number and date protocol
      var object = {
        status_id:status_id
      }
      object.protocol_request_number = result.return.numeroProtocollo + "/" +result.return.anno;
      object.protocol_request_date = new Date();

      var updOpt = {
        id: body.id,
        object: object,
        sysuser_id: opt.sysuser_id,
      };

      roadsite.super_.prototype.update.call(self, updOpt, function(uErr, uRes)
      {
        if (uErr || !uRes)
        {
          var msg = uErr ? "Error on update (protocol request date and protocol number) roadsite: "  + uErr.message :
            "Error on update (protocol request date and protocol number) roadsite";
          self.log.error(self.moduleName + " - "  + msg);
          callback({message:msg},uRes);
          return;
        }

        var retVal = {result:{id: body.id}};
        retVal.result.protocol_request_date = object.protocol_request_date.getTime();
        retVal.result.protocol_request_number = object.protocol_request_number;
        // callback(null,retVal);

        /*
        * Send pec mail to authority
        */
        var mailOpt =
        {
          from: emConfig.smtpPec.from,
          to: emailAuth,
          subject: "RICHIESTA AUTORIZZAZIONE MANOMISSIONE SUOLO PUBBLICO",
          text: "La richiesta di autorizzazione alla manomissione del suolo pubblico " +
          "è stata regolarmente acquisita ed inviata agli uffici competenti con numero " +
          "protocollo " + retVal.result.protocol_request_number + ".\n\n\n\n\n"+
          "-- Questa e-mail è generata automaticamente dal portale GESTIONALE AUTORIZZAZIONI, " +
          "si prega di non rispondere direttamente a questa e-mail. --"
        };

        self.log.info(self.moduleName+" - Sending pec mail for "+authority);

        _smtpPec.sendMail(mailOpt,function(mErr,mRes)
        {
          if (mErr)
          {
            self.log.error(self.moduleName+" - Cannot send pec mail for "+
            authority+": "+mErr.message);

            retVal.error = "ERROR_SEND_PEC";
            callback(null,retVal);
            return;
          }

          callback(null,retVal);

        });
      });
    });
  });
}

roadsite.prototype.approve = function(opt,callback)
{

  var body = opt.body;

  opt.body = {};

  var authority = body.authority;
  delete body.authority;

  var piva = body.piva;
  delete body.piva;

  opt.id = body.id*1;
  opt.body.id = opt.id;

  var status_id = body.status_id;
  delete body.status_id;

  var protocol_request_number = body.protocol_request_number;
  delete body.protocol_request_number;

  var emailAuth = body.emailAuth;
  delete body.emailAuth;

  var town = body.town;
  delete body.town;

  var address = body.address;
  delete body.address;

  self.updateAndUpload(opt, function(errUU,resUU)
  {
    if (errUU)
    {
      self.log.error(self.moduleName + " - Error on approve: "+ errUU.message);

      callback(errUU,null);
      return;
    }
    else
    {
      // Create approval pdf document
      var dir = self.attachment.path + "/" + self.entityName;
      var nameFile = opt.id + "_" + body.approved_attach;
      var fileToSend = dir + "/" + nameFile;

      // Encode file in base64
      var stringBase64 = base64_encode(fileToSend);

      // Send approve
      var reqOpt = {
      host: config.uscita.url, // In ptotocol.json is setted host
      port: 80,
      path: config.uscita.path,
      headers: {"content-type": "application/json"}
      };

      var subject = status_id == STATUS_APPROVE ?
        "Autorizzazione manomissione suolo pubblico" : "Diniego manomissione suolo pubblico"

      var reqBody =
      {
        "protocolloUscitaRequest":
        {
          "destinatari":[
          {
            "ragioneSociale":authority,
            "partitaIva":piva,
            "modalitaSpedizione" : 4
          }],
          "documento":
          {
            "nomeFile":body.approved_attach,
            "contenuto":stringBase64
          },
          "areaOrganizzativaOmogenea":config.uscita.areaOrganizzativaOmogenea,
          "amministrazione":config.uscita.amministrazione,
          "oggetto": subject + " per cantiere " + authority +
          " in " + address + ", " + town,
          "idUtente":config.uscita.idUtente
        }
      };

      self.httpClient.post(reqOpt,JSON.stringify(reqBody),function(resE)
      {
        if (!resE)
        {
          var errMsg = "Cannot retrieve data";
          callback({message:errMsg},null);
          return;
        }

        /* Parse response */
        var result = null;
        try
        {
          result = JSON.parse(iconv.decode(new Buffer(resE),"utf-8"));
        }
        catch(e)
        {
          var errMsg = "Cannot parse data";
          callback({message:errMsg},null);
          return;
        }

        // Save status, number and date protocol
        var object = {
          status_id:status_id,
          approved_user_id: opt.sysuser_id,
        };
        object.protocol_approved_number = result.return.numeroProtocollo + "/" +result.return.anno;;
        object.protocol_approved_date = new Date();
        object.approved_attach = body.approved_attach;

        var updOpt = {
          id: body.id,
          object: object,
          sysuser_id: opt.sysuser_id,
        };

        roadsite.super_.prototype.update.call(self, updOpt, function(uErr, uRes)
        {
          if (uErr || !uRes)
          {
            var msg = uErr ? "Error on update (protocol approved date and protocol number) roadsite: "  + uErr.message :
              "Error on update (protocol approved date and protocol number) roadsite";
            self.log.error(self.moduleName + " - "  + msg);
            callback({message:msg},uRes);
            return;
          }

          var retVal = {result:{id: body.id}};
          retVal.result.protocol_approved_date = object.protocol_approved_date.getTime();
          retVal.result.protocol_approved_number = object.protocol_approved_number;
          //callback(null,retVal);

          /*
          * Send pec mail to authority
          */
          var textMail = status_id == STATUS_APPROVE ?
          "Si comunica che la richiesta di autorizzazione alla manomissione del suolo pubblico " +
          "numero " + protocol_request_number + " è stata autorizzata ed è scaricabile dal portale." :
          "Si comunica che non è possibile autorizzare la manomissione del suolo pubblico numero " +
          protocol_request_number + ". La comunicazione è scaricabile dal portale.";

          textMail = textMail + "\n\n\n\n\n"+
          "-- Questa e-mail è generata automaticamente dal portale GESTIONALE AUTORIZZAZIONI, " +
          "si prega di non rispondere direttamente a questa e-mail. --";

          var subjectMail = status_id == STATUS_APPROVE ? "AUTORIZZAZIONE MANOMISSIONE SUOLO PUBBLICO" : "DINIEGO MANOMISSIONE SUOLO PUBBLICO"

          var mailPecOpt =
          {
            from: emConfig.smtpPec.from,
            to: emailAuth,
            subject: subjectMail,
            text: textMail,
            attachments: [{filename:body.approved_attach,
             path:fileToSend}]
          };

          self.log.info(self.moduleName+" - Sending pec mail for "+authority);

          _smtpPec.sendMail(mailPecOpt,function(mErr,mRes)
          {
            if (mErr)
            {
              self.log.error(self.moduleName+" - Cannot send pec mail for "+
                authority+": "+mErr.message);

              retVal.error = "ERROR_SEND_PEC";
              callback(null,retVal);
              return;
            }

            // Send simple mail to municipal offices
            var townsToSendMail = town.split(";");
            var qTown = "";
            townsToSendMail.forEach(function(elem,idx)
            {
              qTown += "'" + elem + "' = town "
              if (idx != townsToSendMail.length -1)
              {
                qTown += "OR ";
              }
              else
              {
                qTown += ")";
              }
            });
            var query = "SELECT name FROM roadsite_prot_out_email WHERE (town is null or " + qTown;

            var qVal = [];

            self.crud.select({queryString: query},qVal,function(eErr,eRes)
            {

              var emails = eRes.result.map(function(item){return item.name});

              if (!emails.length)
              {
                callback(null,retVal);
              }
              else
              {

                var mailOpt =
                {
                  from: emConfig.smtp.from,
                  to: emails,
                  subject: subjectMail,
                  text: textMail,
                  attachments: [{filename:body.approved_attach,
                    path:fileToSend}]
                };

                self.log.info(self.moduleName+" - Sending simple mail for "+authority + " to " + emails.join());

                _smtp.sendMail(mailOpt,function(mErr,mRes)
                {
                  if (mErr)
                  {
                    self.log.error(self.moduleName+" - Cannot send simple mail for "+
                      authority+": "+mErr.message);

                    callback(mErr);
                    return;
                  }

                  callback(null,retVal);
                });
              }

            });

          });
        });

      });


    }
  });

}

roadsite.prototype.loadShape = function(opt,callback)
{
  self = this;

  var file = opt.files ? opt.files[0] : null;

  var shpOpt = {
    file: file,
    multi: false
  };

  self.shpManager.readShp(shpOpt, function (err,res)
  {
    callback(err,res);
  });
}

roadsite.prototype.updateAndUpload = function(opt,callback)
{
  var body = opt.body;

  // check for attachments
  var files = opt.files ? opt.files : null;

  var dictOldFilename = null;
  if (files && files.length)
  {
    dictOldFilename = {};
    files.forEach(function (item)
    {
      var typeAttach = item.fieldname.substring(0, item.fieldname.length);
      dictOldFilename[typeAttach] = body['old_'+typeAttach];
      delete  body['old_'+typeAttach];
    });
  }


  opt.id = body.id;

  var transName = "UpdateRoadsite_" + new Date().getTime();

  /*
   * Begin transaction
   */
  self.crud.beginTransaction(transName, function(btErr)
  {
    if (btErr)
    {
      callback(btErr,null);
      return;
    }

    if (!body.geoJson && !body.srid)
    {
      var uptOpt = {
        object: body,
        transName: transName,
        sysuser_id: opt.sysuser_id,
        id: opt.id
      };

      roadsite.super_.prototype.update.call(self, uptOpt,function(err,res)
      {
        if (files && files.length)
        {
          var tasks = {};
          for (var idx = 0; idx < files.length; idx++)
          {
            var typeAttach = files[idx].fieldname.substring(0, files[idx].fieldname.length);
            var optUpload = {
              entity_id: opt.id,
              sysuser_id: opt.sysuser_id,
              transName: transName,
              files: [files[idx]],
              oldFilename: dictOldFilename[typeAttach]
            };

            createUploadAttachTask(typeAttach, optUpload, tasks);
          }

          // Execute tasks
          async.parallelLimit(tasks,1,function(errT,resT)
          {
            if (errT)
            {
              // manage tasks error
              self.log.error(self.moduleName + " - Error: " + errT.message);

              self.crud.rollbackTransaction(transName,function(e)
              {
                callback(errT,null);
                return;
              });
            }
            else
            {
              self.crud.commitTransaction(transName, function(e)
              {
                callback(e,e ? null : res);
              });
            }
          });

        }
        else
        {
          self.crud.commitTransaction(transName, function(e)
          {
            callback(e,e ? null : res);
          });
        }
      });
    }
    else
    {
      var rsGeom = null;

      if (!body.geoJson || !body.srid)
      {
        var errMsg = "Missing parameters";

        self.log.error(self.moduleName + " - Save geoJson error: " + errMsg);
        self.crud.rollbackTransaction(transName,function(e)
        {
          callback({message: 1},null);
          return;
        });
      }

      /*
      * build geometry to update from received geoJSON as:
      *
      * ST_Transform(ST_SetSRID(ST_GeomFromGeoJSON(<geoJSON>),<geom_srid>),<table_srid>)
      *
      */
      //geom = JSON.stringify(body.geoJson);
      geom = body.geoJson;

      rsGeom = "ST_Transform(ST_SetSRID(ST_GeomFromGeoJSON('" + geom + "')," + body.srid + ")," + self.tableSrid + ") ";

      // remove geoJson and srid from input object
      delete body.geoJson;
      delete body.srid;

      // build update query
      var qStrU = "UPDATE " + self.tableName + " AS NEW SET ";
      var qRet  = "RETURNING OLD.id,";
      var qVal  = [];
      var index = 1

      // cycle on attributes to build dinamically attrs and values list
      Object.keys(body).forEach(function(key)
      {
        switch(key)
        {
          default:
            qStrU += (key + " = $" + index + ",");

            var valueObj = {value:body[key]};

            if (key == 'start_date')
              valueObj.type = self.crudUtils.TIMESTAMP;

            if (key == 'end_date')
              valueObj.type = self.crudUtils.TIMESTAMP;

            qVal.push(valueObj);

            qRet  += "OLD." + key + ", ";
        }

        index++;
      });

      qStrU  += ("geom=" + rsGeom);

      qRet +=
        "round(st_xmin(st_envelope(NEW.geom))::numeric,2)::float AS x_min," +
        "round(st_ymin(st_envelope(NEW.geom))::numeric,2)::float AS y_min," +
        "round(st_xmax(st_envelope(NEW.geom))::numeric,2)::float AS x_max," +
        "round(st_ymax(st_envelope(NEW.geom))::numeric,2)::float AS y_max;";

      // add FROM
      qStrU += " FROM " + self.tableName + " AS OLD ";

      // add where condition
      qStrU += " WHERE OLD.id = $" + index + " AND OLD.id = NEW.id ";

      // add returning option
      qStrU += qRet;

      // add natural disaster history id into val array
      qVal.push({value: opt.id});

      opt.queryString = qStrU;

      // execute update
      self.crud.update(opt, qVal, function(err,res)
      {
        if (err)
        {
          self.log.error(self.moduleName + " - Error on update roadsite:" + err.message);
          self.crud.rollbackTransaction(transName,function(e)
          {
            callback(err,null);
            return;
          });
        }
        else
        {
          if (files && files.length)
          {
            var tasks = {};
            for (var idx = 0; idx < files.length; idx++)
            {
              var typeAttach = files[idx].fieldname.substring(0, files[idx].fieldname.length);
              var optUpload = {
                entity_id: opt.id,
                sysuser_id: opt.sysuser_id,
                transName: transName,
                files: [files[idx]],
                oldFilename: dictOldFilename[typeAttach]
              };

              createUploadAttachTask(typeAttach, optUpload, tasks);
            }

            // Execute tasks
            async.parallelLimit(tasks,1,function(errT,resT)
            {
              if (errT)
              {
                // manage tasks error
                self.log.error(self.moduleName + " - Error: " + errT.message);

                self.crud.rollbackTransaction(transName,function(e)
                {
                  callback(errT,null);
                  return;
                });
              }
              else
              {
                self.crud.commitTransaction(transName, function(e)
                {
                  callback(e,e ? null : res);
                });
              }
            });

          }
          else
          {
            self.crud.commitTransaction(transName, function(e)
            {
              callback(e,e ? null : res);
            });
          }
        }
      });

    }
  });
}

/*
 * Private methods
 */

// build task to manage upload attach
function createUploadAttachTask(typeAttach, opt, tasks)
{
  tasks['uploadAttach_' + typeAttach] = function(cb){uploadAttach(opt, cb);};
}

// manage roadsite attach upload
function uploadAttach(params,callback)
{
  var file = params.files ? params.files[0] : null;
  var entityId = params.entity_id;
  var uploadDir = self.attachment.path;

  if (!file || entityId == null || !uploadDir)
  {
    var errMsg = "Missing parameters";

    self.log.error(self.moduleName + " - Upload error: " + errMsg);
    return callback({message: errMsg},null);
  }

  /* Move uploaded file into entity dir */
  var dir = uploadDir+"/"+self.entityName;
  var filename = dir+"/"+entityId+"_"+file.originalname;

  if (params.oldFilename)
  {
    // Remove old file
    fs.unlink(dir+"/"+entityId+"_"+params.oldFilename,function(unlErr){});
  }

  // Look for entity dir
  if (!fs.existsSync(dir))
  {
    try {fs.mkdirSync(dir);}
    catch (err)
    {
      self.log.error(self.moduleName + " - Upload error: " + err.message);
      return callback(err,null);
    }
  }

  // Move file
  fs.rename(file.path,filename,function(err)
  {
    if (err)
    {
      var errMsg = "Cannot move file";

      self.log.error(self.moduleName + " - Upload error: " + errMsg);
      return callback({message: errMsg},null);
    }

    callback(err,filename);

  });
}

// function to encode file data to base64 encoded string
function base64_encode(file)
{
  // read binary data
  var bitmap = fs.readFileSync(file);
  // convert binary data to base64 encoded string
  return new Buffer(bitmap).toString('base64');
}



